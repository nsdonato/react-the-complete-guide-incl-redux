
# Section 1: Getting Started

    1. Welcome To The Course!
        ...

    2. What is React.js?
        Que, como y porque:

        Una /libreria de JavaScript/ para crear interfaces de usuario (Componentes)

        - Basicamente, se crean aplicaciones Javascript, que corren en el navegador, no corren en el servidor. No tenemos que esperar una respuesta del servidor para obtener una nueva página o para renderizar algo nuevo.

        - User interface: Interfaz de usuario, es lo que el usuario puede ver. Con React construimos componentes, para la interfaz de usuario, que a su vez, se pueden reutilizar.

        Joining it is of course free and 100% optional.

    3. Why React Instead Of "Just JavaScript"?
        
        https://github.com/academind/react-complete-guide-code/tree/01-getting-started/code/
        react-vs-vanilla-js-example

        Porque tendríamos que repetir código y con react creamos componentes y reutilizamos lso mismos.

    4. Building Single-Page Applications (SPAs) with React
        
        React puede ser usado para controlar partes de una pagina html o la pagina entera
            "Widget" approach on a multi-page-application, algunas paginas siguen siendo renderizadas y servidas por un servidir backend.

        React también puede ser usado para controlar una frontend entero o una app web.
            "SPA" approach. El servidor envia solamente UN HTML y toma control de la UI.

    5. Exploring React.js Alternatives (Angular / Vue)

        Angular 
            Te sirve para enforcarte en la logica y en el modelo de negocio, y no tanto en el aspecto del elemento en particular que querías cambiar (como en react). Podrian no convenir para proyectos pequeños ya que encima tenes que saber TypeScript.

        Vue.js
            Complete component based UI fw, incluye most core features. Menos popu que react y angular.

    6. Join our Online Learning Community

        Join our Online Learning Community
        As a student of this course you also get free access to our "Academind Community" on Discord: https://academind.com/community/

        There, you can find like-minded people, discuss issues, help each other, share progress, successes and ideas and simply have a good time!

        I believe that you learn the most if you don't learn alone but find learning partners and other people with similar interests. Our community is a great place for this - it's the perfect complimentary resource for this course.

        Joining it is of course free and 100% optional.

    7. About This Course & Course Outline
        ...

    8. The Two Ways (Paths) Of Taking This Course
        Standar (recomendado)   
            Arrancar por el principio, ir paso por paso, skipear el javascript refresher si no lo necesitas, mirar los summary para ver que aprendiste también los podes ver en el futuro para refrescar lo aprendido

        Enfoque resumido, si estas apurado:
            ir directamente solo a los modulos de resumen
            hacer el modulo de refresher js solo si lo necesitas.
            mirar todo el curso después de mirar los summary si tenes mas tiempo en el futuro
        
    9. Getting The Most Out Of This Course
        Te recomienda como ver el curso para sacarle jugo..

    10. Setting Up The Course Dev Environment (Code Editor)
        Instala VS Code

# Sección 2: Javascript Referesher

    11. Module Introduction
        Next-Gen Javascript, para refrescar. React usa esto, así que, hay que saberlo.

    12. Understanding "let" and "const" - 

        let = var (cambia el tema del scope, porque ahora es de bloque.)
        const = para info que no va a cambiar.

    13. Arrow Functions - 

        funciones antes:
            function myFuncion() {
                ...
            }

        funciones ahora:
            const myFuncion = () => {
                ...
            }

        * Arrow functions, mejoran el problema de que this, no siempre apuntaba al contexto de ejecución, sino al objeto global.
        * Si no tiene parametros, va solo parentesis
        * Si tiene uno, es param =>
        * Si tiene mas de uno, es (param1,param2) =>
        * Si la parte de retorno solo tiene una linea, se puede escribir así: const multiplicar = number => number * 2;

    14. Exports and Imports - 

        Para modular el código, para dividir los archivos js en varios archivos.
            Si bien ya se puede (porque agregas diferentes archivos en el html, de manera ordenada)
            Ahora desde un js, se puede usar info de otro js.

        EXPORTAR
            person.js
                const person = {
                    name: 'Max'
                }
                export default person

                // export: sirve para exportar esa función, objeto, etc, desde un archivo.
                // default: que esa funcion, obj, etc, va a ser la predeterminada.
                // person: en este caso es el objeto

            utility.js
                export const clean = () => { ... }
                export const baseData = 10;

        IMPORTAR
            app.js
                // Se pone de alguna de las dos maneras, ya que hace referencia a lo único que se exporto (default)

                    import person from './person.js'
                    import prs from './person.js'

                // Al ser exportada como diferentes constantes, se usa las { }  para "mejorar el codigo", diciendo que se esta exportando algo especifico
                // Tiene que respetar el nombre que se le puso en el archivo donde se la exporta obj
                // se puede ponerle un alias, como en la segunda linea

                    import { baseData } from './utility.js'
                    import { baseData as bd } from './utility.js'

                // También se podría hacer de esta manera.

                    import { baseData, clean } from './utility.js'

    15. Understanding Classes - 

        - Los metodos son como: funciones atachados a esa clase/objetos,
        - las propiedades son como: variables, atachadas a esa clase/objetos,

        class Human {
            constructor(){
                this.gender = 'male';
            }

            printGender(){
                consoe.log(this.gender);
            }
        }

        // Herencia
        class Person extends Human{
            constructor(){
                super();
                this.name = 'Max';
                this.gender = 'female'; // pero no es correcto usar así.
            }

            printMyname (){
                console.log(this.name);
            }
        }

        // Instanciar un objeto de esa clase.
        const miPersona = new Person();
        miPersona.printMyname();
        miPersona.printGender();

    16. Classes, Properties and Methods - 

        ES6
        Propiedades:
            constructor() {
                this.myProperty = 'value'
            }

        Metodos:
            miMetodo () {
                ...
            }

        ES7
        Propiedades:
            myProperty = 'value'; // Si, no hay un "constructor" en si.

        Metodos:
            miMetodo = () => {
                ...
            }

        * Es mejor usar ambos opciones de ES7, para esto si o si hay que usar ES6/Babel, que transpila el código y lo convierte.

    17. The Spread & Rest Operator - 

        // Operator Spread o Rest (depende de donde se use)
        ...

        Spread: (división de las propiedades de un objeto o un array.)

                Se usa para dividir elementos de un array o propiedades de un objeto.
                Por ejemplo, si tenemos una matriz antigua y queremos agregar todos los elementos de esa matriz anterior a una nueva matriz y,
                además, agregar un 1 en un elemento dos, este primer índice sería lo que tenía tres puntos delante
                de toda la matriz. simplemente extraiga todos los elementos y agregue a la nueva matriz que
                creamos con corchetes.

                // Idem object pero array
                    const oldArray = [3,4,5];
                    const newArray = [...oldArray,1,2];
                    console.log(newArray);
                    // 3,4,5,1,2

                // Lo probé, lo que hace es agarrar las propiedades/funciones del objeto viejo, y ponerselo al nuevo y suma la nueva prop/func.
                const oldObject = {
                    name: "Noe";
                }

                const newObject = { ...oldObject, newProp: 5 }
                console.log(newO)

        Rest: (Fusión de elementos en un array)

            Se utiliza con menos frecuencia.

            Se usa para mergear una lista de argumentos de funciones en una matriz.
            O sea, lo usamos en el parametro de una función. ej:

            // Recibe una lista ilimitada de argumentos, y todos se fusionan en un array.
            // O sea, en vez de dividir, los une.

            function sortArgs(...args){
                return args.sort[];
            }

            sortArgs(1,2,3,4,5);

        * Hay que tener en cuenta que si el numero o propiedad / funcion, ya existia en el objeto actual, lo sobreescribe.

        array.filter()  // ejecuta una función en cada elemento de la matriz y se verifica si existe un elemento en ella, ej:
        const filter = (...args) => {
            return args.filter(el => el === 1);
        }

        console.log(filter(1,2,3));
        // [1]

    18. Destructuring - 

        Permite extraer facilmente elementos de una matriz o propiedades de objetos y guardarlos en variables.
        ej:

        array:
            [nombre, apellido] = ['Noe','Donato'];
            console.log(nombre); // Noe
            console.log(apellido); // Donato

            const numbers = [1,2,3];
            [num1, num2] = numbers;
            console.log(num1,num2); // 1 2

            [num1, ,num3] = numbers;
            console.log(num1,num3); // 1 3

        object:
            { name } = { name: 'Noe', age: '32' };
            console.log(name); // Noe
            console.log(age); // undefined

    19. Reference and Primitive Types Refresher - 

        Primitivos
        * Copia el valor de su variable en otra, osea hay 2.
        number, boolean, string

        Referencia
        * No copia, sino que hace referencia al puntero en memoria del otro objeto.
        Object, arrays.

            const person = {
                name: 'Max'
            };
            const secPerson = person;
            person.name = 'Manu';

            console.log(secPerson); // 'Manu'

        Para copiar un objeto, o sea generar uno nuevo, deberíamoshacer:
            const person = {
                name: 'Max'
            };
            const secPerson = {
                ...person
            };
            person.name = 'Manu';

            console.log(secPerson); // 'Max'

    20. Refreshing Array Functions - 

        const numbers = [1,2,3];

        // La función se va a ejecutar por cada elemento
        // Al parametro le ponemos num, porque esta recorriendo numeros, como para ser claros.
        const numbers = [1,2,3];
        const doubleNumArray = numbers.map((num) => num * 2 );
        console.log(doubleNumArray); // [2,4,6]

    21. Wrap Up

        Basicamente que cualquier cosa, se puede volver a esas clases para refrescar por si te olvidaste algo.

    22. Next-Gen Javascript - Summary
        In this module, I provided a brief introduction into some core next-gen JavaScript features, of course focusing on the ones you'll see the most in this course. Here's a quick summary!

        let & const
        Read more about let : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let

        Read more about const : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const

        let  and const  basically replace var . You use let  instead of var  and const  instead of var  if you plan on never re-assigning this "variable" (effectively turning it into a constant therefore).

        ES6 Arrow Functions
        Read more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions

        Arrow functions are a different way of creating functions in JavaScript. Besides a shorter syntax, they offer advantages when it comes to keeping the scope of the this  keyword (see here).

        Arrow function syntax may look strange but it's actually simple.

        function callMe(name) { 
            console.log(name);
        }
        which you could also write as:

        const callMe = function(name) { 
            console.log(name);
        }
        becomes: 

        const callMe = (name) => { 
            console.log(name);
        }
        Important: 

        When having no arguments, you have to use empty parentheses in the function declaration:

        const callMe = () => { 
            console.log('Max!');
        }
        When having exactly one argument, you may omit the parentheses:

        const callMe = name => { 
            console.log(name);
        }
        When just returning a value, you can use the following shortcut:

        const returnMe = name => name
        That's equal to:

        const returnMe = name => { 
            return name;
        }
        Exports & Imports
        In React projects (and actually in all modern JavaScript projects), you split your code across multiple JavaScript files - so-called modules. You do this, to keep each file/ module focused and manageable.

        To still access functionality in another file, you need export  (to make it available) and import  (to get access) statements.

        You got two different types of exports: default (unnamed) and named exports:

        default => export default ...; 

        named => export const someData = ...; 

        You can import default exports like this:

        import someNameOfYourChoice from './path/to/file.js'; 

        Surprisingly, someNameOfYourChoice  is totally up to you.

        Named exports have to be imported by their name:

        import { someData } from './path/to/file.js'; 

        A file can only contain one default and an unlimited amount of named exports. You can also mix the one default with any amount of named exports in one and the same file.

        When importing named exports, you can also import all named exports at once with the following syntax:

        import * as upToYou from './path/to/file.js'; 

        upToYou  is - well - up to you and simply bundles all exported variables/functions in one JavaScript object. For example, if you export const someData = ...  (/path/to/file.js ) you can access it on upToYou  like this: upToYou.someData .

        Classes
        Classes are a feature which basically replace constructor functions and prototypes. You can define blueprints for JavaScript objects with them. 

        Like this:

        class Person {
            constructor () {
                this.name = 'Max';
            }
        }
        
        const person = new Person();
        console.log(person.name); // prints 'Max'
        In the above example, not only the class but also a property of that class (=> name ) is defined. The syntax you see there, is the "old" syntax for defining properties. In modern JavaScript projects (as the one used in this course), you can use the following, more convenient way of defining class properties:

        class Person {
            name = 'Max';
        }
        
        const person = new Person();
        console.log(person.name); // prints 'Max'
        You can also define methods. Either like this:

        class Person {
            name = 'Max';
            printMyName () {
                console.log(this.name); // this is required to refer to the class!
            }
        }
        
        const person = new Person();
        person.printMyName();
        Or like this:

        class Person {
            name = 'Max';
            printMyName = () => {
                console.log(this.name);
            }
        }
        
        const person = new Person();
        person.printMyName();
        The second approach has the same advantage as all arrow functions have: The this  keyword doesn't change its reference.

        You can also use inheritance when using classes:

        class Human {
            species = 'human';
        }
        
        class Person extends Human {
            name = 'Max';
            printMyName = () => {
                console.log(this.name);
            }
        }
        
        const person = new Person();
        person.printMyName();
        console.log(person.species); // prints 'human'
        Spread & Rest Operator
        The spread and rest operators actually use the same syntax: ... 

        Yes, that is the operator - just three dots. It's usage determines whether you're using it as the spread or rest operator.

        Using the Spread Operator:

        The spread operator allows you to pull elements out of an array (=> split the array into a list of its elements) or pull the properties out of an object. Here are two examples:

        const oldArray = [1, 2, 3];
        const newArray = [...oldArray, 4, 5]; // This now is [1, 2, 3, 4, 5];
        Here's the spread operator used on an object:

        const oldObject = {
            name: 'Max'
        };
        const newObject = {
            ...oldObject,
            age: 28
        };
        newObject  would then be

        {
            name: 'Max',
            age: 28
        }
        The spread operator is extremely useful for cloning arrays and objects. Since both are reference types (and not primitives), copying them safely (i.e. preventing future mutation of the copied original) can be tricky. With the spread operator you have an easy way of creating a (shallow!) clone of the object or array. 

        Destructuring
        Destructuring allows you to easily access the values of arrays or objects and assign them to variables.

        Here's an example for an array:

        const array = [1, 2, 3];
        const [a, b] = array;
        console.log(a); // prints 1
        console.log(b); // prints 2
        console.log(array); // prints [1, 2, 3]
        And here for an object:

        const myObj = {
            name: 'Max',
            age: 28
        }
        const {name} = myObj;
        console.log(name); // prints 'Max'
        console.log(age); // prints undefined
        console.log(myObj); // prints {name: 'Max', age: 28}
        Destructuring is very useful when working with function arguments. Consider this example:

        const printName = (personObj) => {
            console.log(personObj.name);
        }
        printName({name: 'Max', age: 28}); // prints 'Max'
        Here, we only want to print the name in the function but we pass a complete person object to the function. Of course this is no issue but it forces us to call personObj.name inside of our function. We can condense this code with destructuring:

        const printName = ({name}) => {
            console.log(name);
        }
        printName({name: 'Max', age: 28}); // prints 'Max')
        We get the same result as above but we save some code. By destructuring, we simply pull out the name  property and store it in a variable/ argument named name  which we then can use in the function body.

        Resources for this lecture
        next-gen-js-summary.pdf

    23. JS Array Functions
        En realidad, no la próxima generación de JavaScript, pero también es importante: un arreglo de funciones de JavaScript, como map() , filter() , reduce()  etc.
        Me verás usarlos bastante ya que muchos conceptos de React se basan en trabajar con arreglos (de manera inmutable).

        La siguiente página ofrece una buena descripción general de los diversos métodos que puede utilizar en el prototipo de matriz. No dude en hacer clic en ellos y actualizar sus conocimientos según sea necesario:
            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

        Particularmente importantes en este curso son:

        map()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
        find()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
        findIndex()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
        filter()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
        reduce()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b
        concat()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat?v=b
        slice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
        splice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice

# Section 3: React Basics & Working With Components

    24. Module Introduction
        ...

    25. What Are Components? And Why Is React All About Them?
        React crea interfaces simples itneractivas y reactivas al usuario.
        
        Componentes: son una composición de html, css y js son reusables. todos los componentes unidos forman una interface de usuarios.

        Porque componentes?
        Reusabilidad:
            DRY 
        Separation of Concerns: 
            No hacer demsiasdo en una sola función. Separarlos en funciones mas chicas.

    26. React Code Is Written In A "Declarative Way"!

        Como se construye un componente? 
            html, css y js
                aunque css no es principalmente lo importante, sino html y js
            
        Declarative approach: que react no le va a decir a react que un html fue creado.
        defina el estado de destino deseado y deje que React descubra las instrucciones DOM de JavaScript reales

    27. Creating a new React Project
        https://github.com/academind/react-complete-guide-code/tree/03-react-basics-working-with-components/code

        new_resources/01-starting-setup.zip

        npm start -> arrancar la app
        ctrl+c -> cancelar la ejecución.

    28. The Starting Project
        In case you skipped the previous lecture, attached you find the starting project snapshot.

        Download it

        Extract it

        run npm install in the extracted folder

        Run npm start to start the development server.

        Resources for this lecture
        01-starting-setup.zip
        Section Code Snapshots

    29. Analyzing a Standard React Project
        index.js es el primer archivo que se ejecuta.

        ambas son parte de la misma libreria, pero se separan las responsabilidades en dos package diferentes.
            react 
            react-dom 

        index.js
            import React from 'react';
            import ReactDOM from 'react-dom';
            import './index.css';
            import App from './App';
            import * as serviceWorker from './serviceWorker';

            // Siempre vamos a tener un elemento donde van a estar todos los componentes
            // y que lo vamos a renderizar en un id x ej root. 
            ReactDOM.render(<App />, document.getElementById('root'));

        app.js
            import React, { Component } from 'react';
            import './App.css';

            class App extends Component {
                render() {
                    return (
                        <div className="App">
                            <h1>Hola, soy una App React</h1>
                        </div>
                    );
                }
            }

            export default App;

        - Para definir un componente, hay 2 maneras.
            1)
                1.1) Creamos una clase y lo hacemos heredar de Component,

                    que se importa de la libreria de react.
                    React, se importa porque es necesario para renderizar el componente y el objeto componente.

                1.2) el metodo render()
                        sirve para renderizar JSX en la pantalla.

            2) crear una función.
        
        * Por lo general cuando se elige el nombre de un componente, se usa ese nombre para la variable a importar, para el archivo y para el elemento.
        * Los archivos también podrían llamarse JSX, pero se usa js por convención.
            JSX en realidad es lo que llaman "syntactic sugar". Es una sintaxis dentro de un lenguaje de programación, diseñado para ser mas facil de leer o expresarse.
            Es como "mas dulce para que lo pueda usar una persona"

    30. Introducing JSX

        Javascript Xml -> es el standar
        es html con js

        son archivos con codigo transformado, ya que jsx no es soportado en los browsers.
            0.chunk.js
            bundle.js
            main.chunk.js      
        
    31. How React Works
        Creamos nuestros propios componentes html.

        Imperative instructions son las que se usan en js normal.
        En react es declarative way.

    32. Building a First Custom Component
        BEST PRACTICE: new components -> new files.

        root, es nuestro main container.

        React tiene su tree, que parte desde App

        crea:
            components/
                ExpenseItems.js -> convensión Pascal Case

                La gran mayor cantidad de tiempo los componentes se crean como el de app, pero por lo general son solo funciones.

        Para crear un componente entonces (que no derive de Component):
            Generamos una función.
            La exportamos como default.
            Retornamos JSX

        Para usar en nuestro component App:
            Importamos el componente.
            Dentro del html que estamos retornando, agregamos el tag con nuestro componente.

        <ExpenseItems /> // lo podemos dejar así ya que no tenemos que anidar nada adentro.

    33. Writing More Complex JSX Code
        - Como en realidad el html que vemos es JSX, no podemos usar palabras reservadas como class, debemos en este caso, por ej usar className, en el elemento.

        - No podemos devolver elementos que no tienen un padre. Por ej, no podemos poner un elemento hermano al div root.

        - Es buena practica, es meter todo dentro de un contenedor a devolver.

    34. Adding Basic CSS Styling
        https://github.com/academind/react-complete-guide-code/blob/03-react-basics-working-with-components/extra-files/ExpenseItem.css

        bajarse el archivo y ponerlo en la misma ruta que el js e importarlo.

        Tener en cuenta que no se puede usar class, ya que es una palabra reservada, por ende hay que usar className, al igual que for, es htmlFor, etc...

    35. Outputting Dynamic Data & Working with Expressions in JSX
        Para que el js, no sea interpretada como texto, se debe usar {js que quiera}

            return <p>Soy una persona and I am {Math.floor(Math.random() * 30)} years old! </p>

        Esto se usa para simples calculos o llamadas a funciones, pero nada mas, debería ser solo una linea de codigo

        En la actualización da un ejemplo creando una variable fecha y actualizando en el código donde estaba hardcoding.

    36. Passing Data via "props"
        Dejo el ejemplo viejo, en el nuevo lo explica lo mismo con <ExpensiveItems />
        https://github.com/academind/react-complete-guide-code/blob/03-react-basics-working-with-components/extra-files/expenses.txt

        Trabajar componentes en archivos separados, hace que el codigo sea mas mantenible.
        Aparte se lo puede configurar y reutilizar.
        return (
            <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person />
            <Person />
            <Person />
            </div>
        );

         return (
            <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person name="Max" age="28"/>
            <Person name="Manu" age="29"/>
            <Person name="Noe" age="32"/>
            </div>
        );

        Del componente principal, se le pasa al componente que corresponde el valor de las propiedades, name y age en este ejemplo.

        Person.js
            #IMPORTANTE:
            El argumento es un objeto con toda la info que se le pasa al componente, se puede llamar props, como se puede llamar pepito.

            const person = (props) => {
                return <p>Hola! Soy {props.name} y tengo {props.age} años! </p>
            }

        Cuanto se usa en una clase-componente (como app), se tiene que usar this.props

    37. Adding "normal" JavaScript Logic to Components
        crea diferentes variables y utiliza funciones propias de js, que usa en el código jsx.

    38. Splitting Components Into Multiple Components
        Crea un segundo componente ExpenseDate.js pone lo referido a las fechas ahí y lo importa en ExpenseItem.js apare ahora se puede reutilizar en cualquier parte de la app.

        Al componente le pasa las props necesarias para que funcione.
        
        Importa un css a ExpenseDate: https://github.com/academind/react-complete-guide-code/blob/03-react-basics-working-with-components/extra-files/ExpenseDate.css

    Assignment 1: Time to Practice: React & Component Basics
        TODO: después hago esta tarea nueva..

    39. The Concept of "Composition" ("children props")
        Explicación vieja, en lo nuevo explica lo mismo pero crando una card y en props usa la prop children.

        Si queremos pasar algo entre la etiqueta de apertura y cierre, tenemos que envolver eso en un elemento padre y usar children.

        <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person name="Max" age="28"/>
            <Person name="Manu" age="29">My hobbies: Racing</Person>
            <Person name="Noe" age="32"/>
        </div>

        Person.js
         <div>
            <p>I'm {props.name} and I am {props.age} years old!</p>
            <p>{props.children}</p>
         </div>

    40. A First Summary
        TODO: Lo veo a lo último del curso.

    41. A Closer Look At JSX
        En las nuevas versiones de react, no es necesario importar React. React lo utiliza under the hood.

        Explicación vieja, que aplica a esta sección.
        Componente basado en clase:
        class App extends Component {
            render() {
                // Podemos usar el objeto de React para crear un elemento.
                // createElement, toma infinitos argumentos, pero el primero es o un elemento o un componente.
                // 2 arg: puede ser un objeto, aunque es opcional, por lo tanto pasamos null
                // 3 arg, los hijos: a partir de ese, van separados por comas, y basicamente s todo lo que va a ir, adentro del primer arg, el div en este caso.
                    1 linea: como el comportamiento por default es tomar todo por texto, va a imprimir en pantalla, h1Iamreactapp,
                    2 lines: así que hay que usar otro react.createelement...
                    3 linea: Para pasarle estilo

                //return React.createElement('div', null, 'h1','I\'m a React App!!!!');
                //return React.createElement('div', null, React.createElement('h1',null,'I\'m a React App!!!!'));
                return React.createElement('div', { className: 'App'}, React.createElement('h1',null,'I\'m a React App!!!!'));

            }
        }

        * NO SE USA CREAR LOS ELEMENTOS ASÍ, es para que sepamos que existe esto y no es lo correcto.
        Para eso se genera el "HTML, que en realidad es JSX" = javascript.

    42. Organizing Component Files
        components/
            Expenses/
                ExpenseDate.js
                ExpenseDate.css
                ExpenseItem.js
            UI -> interfaces elements

        Siempre igual depende de vos o el equipo en el que trabajes.

    43. An Alternative Function Syntax
        Muestra como cambiar de function ExpensiveDate a arrow functions ...

    Quiz 1: Learning Check: React Basics, Components, Props & JSX
        TODO: lo hago a lo ultimo

    44. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/03-react-basics-working-with-components

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 4: React State & Working with Events

    45. Module Introduction
        ...

    46. Listening to Events & Working with Event Handlers
        React expone eventos que arrancan con on
        onClick, onChange, etc..

        Explicación vieja, en la nueva lo hace sobre un boton de ExpenseItem:
            // en JSX es con la C mayus. 
            <button onClick=>Cambiar de nombre</button>

            es buena practica ponerle al final Handler, a la función que haga de handler.

            switchNameHanlder = () => {
                console.log("click");
            }

            a la función no hay que ponerle los () para que no lo llame en ese mismo momento.

            <button onClick={this.switchNameHanlder}>Cambiar de nombre</button>

    47. How Component Functions Are Executed
        Tu componente es una función regular que retorna JSX, cuando el componente se utiliza en algun lugar de la pagina se llama al mismo como si fuera una función, verifica todas las funciones que hay que ejecutar hasta que termina renderizando el componente.

        React no repite todo eso, lo hace solo cuando renderiza toda la pagina por primera vez, por lo que para que reevalue algo que cambio, se utiliza el state.

    48. Working with "State"
        Explicación nueva para functional components:
            import React, { useState } from 'react' -> es una función (hook) que provee React que nos habilita encontrar valores como estado, que cuando cambian esos valores, debe reflejar en la functional component.
            
            Se coloca dentro de la función del componente:
            Los hooks solo van dentro de la functionals components.
            Todos arrancan con useXxxx

            const ExpensiveItem = (props) => {
                
                // const [valor, functionQueUpdateaElstado] = useState(valorInicial, puede ser obj, arrat, variable, etc..)
                
                const [title,setTitle] = useState(props.title) 

                const clickHandler = () => {
                    setTitle('updated') // es manejado por react en algun lugar de la memoria, actualiza la variable title. re-renderiza el componente, ya que re-evalua todo el jsx de la función y actualiza solo lo necesario
                }
            }
        

        Explicación vieja:

        Hasta React 16.8 setState era la unica manera de manejar estados en las aplicaciones de React.

        Ahora hay una característica llamada React Hooks, se utiliza mas que nada en los componentes de funciones.

        IMPORTANTE: El va a seguir enseñando la manera tradicional (clases basadas en componentes) porque en las compañias ya tienen proyectos hechos basados en esto.

        Si bien desde React 16.8 podemos usar componentes funcionales para todo, vamos a mantenernos en las clases basadas en componentes, porque el dice que en los laburos se usa mas eso.

        "react hooks"
            Es una colección de funciones expuestas por React para que puedas en componentes funcionales y demás, una de ellas es useState.

            Cambia el componente app por uno funcional o sea,
                const app = props => {
                    useState({
                        mete el array de persons
                    });

                    return() { JSX }
                }

            Este es un componente funcional normal, pero ahora puede usar la función de "react hooks" o una de las funciones de React.
            --> Para eso hay que importarlo:  import React, { useState } from 'react' (React ya lo teníamos, solo agregamos { useState })

            UseState:
                Devuelve una matriz con exactamente dos elementos y siempre dos elementos que son importantes.

                    // Usamos destructuración [ param1, param 2] , lo que hace que useState ponga la info en donde corresponda.
                    const [ currentState, updateCurrentState ] = useState({});

                    1) Ahora el primer elemento que recibimos siempre será nuestro estado actual.
                    2) El segundo elemento en la matriz de estado siempre será una función que nos permita actualice este estado para que react lo sepa y volverá a procesar este componente
                        IMPORTANTE: La 2da función no mergea los cambios, pisa el objeto con el nuevo estado.

                    3) Si estabamos usando this.state ahora debemos cambiarlo por currentState

            <button>Cambiar de nombre</button>

            state:
                - SOLO SE PUEDE USAR: En las clases-componentes
                - es una propiedad especial, donde se establecen y pasan props desde afuera como name, age etc, y que se gestionan dentro del componente.
                    Si cambiamos algo que use esta propiedad, va a renderizar nuevamente el dom/componente.

                Se inicializa como un objeto.
                    state = {}
                Se le pueden agregar, array objetos:
                    state = {
                        persons: [
                            { name: 'Noe', age: 32 },
                            { name: 'Gia', age: 29 },
                            { name: 'Nany', age: 33 },
                        ]
                    }

                Una vez que hacemos esto, la podemos usar en nuestro metodo dinamico.

                <div className="App">
                <h1>Hola, soy una App React</h1>
                <button>Cambiar de nombre</button>
                <Person name={this.state.persons[0].name} age={this.state.persons[0].age}/>
                <Person name={this.state.persons[1].name} age={this.state.persons[1].age}>My hobbies: Racing</Person>
                <Person name={this.state.persons[2].name} age={this.state.persons[2].age}/>
                </div>

                props.children mostraría por ej en el componente Person "My hobbies: Racing"

            this, hace referencia a la clase donde se esta usando

    49. A Closer Look at the "useState" Hook
        Cada State es unico en cuanto a su componente, por ejemplo en una lista, si aprestas un botno especifico que actualiza un texto de su row, es de esa row el cambio no de todos.

        si hay 4 rows en la primera renderizada, va a haber 4 renderizados, en la segunda por ej a un click, solo uno.

        Cuando se renderiza el componente, react en primera instancia guardo los estados que pudiera haberse inicializado y en los demás, solo actualiza aquel que realmente se haya actualizado.

    50. State can be updated in many ways!
        Thus far, we update our state upon user events (e.g. upon a click).

        That's very common but not required for state updates! You can update states for whatever reason you may have.

        Later in the course, we'll see Http requests that complete (where we then want to update the state based on the Http response we got back) but you could also be updating state because a timer (set with setTimeout()) expired for example.

    51. Adding Form Inputs
        https://github.com/academind/react-complete-guide-code/blob/04-react-state-events/extra-files/ExpenseForm.css
        https://github.com/academind/react-complete-guide-code/blob/04-react-state-events/extra-files/NewExpense.css

        genera el form y los inputs..

    52. Listening to User Input
        pone un onChange en un input, explica como setear el estado desde la función que handlea el evento.

        event.target.value

        Explicación vieja para class components:
            switchNameHanlder = () => {
                // No hay que mutar de esta manera (cambiar de estado), va a dar un error.
                //this.state.persons[0].name = 'Noelia';
                this.setState({
                    persons: [
                        { name: 'Noeñs', age: 32 },
                        { name: 'Gabuns', age: 29 },
                        { name: 'Nanys', age: 33 },
                    ]
                )
            }

            setState:
                Esta disponible solo en clases basadas en componentes.

                Este es un método que nos permite actualizar esta propiedad state, después
                nos aseguramos de que react conozca como la actualización y react actualice el DOM.

                // Toma un objeto como argumento y fusionara (sobreescribe) eso con nuestro estado actual
                switchNameHanlder = () => {
                    this.setState({
                        persons: [
                            { name: 'Noels', age: 32 },
                            { name: 'Gabuns', age: 29 },
                            { name: 'Nanys', age: 33 },
                        ]
                    })
                }

                * Solo se pueden cambiar props y state

    53. Working with Multiple States
        const [title,setTitle] = useState(props.title) 
        const [name,setName] = useState(props.name) 
        const [lastName,setLastName] = useState(props.lastName) 

    54. Using One State Instead (And What's Better)
        const [data,setData] = useState({
            name: props.name,
            lastName: props.lastName,
            title: props.title
        }) 

        Para no perder los estados ahora que estan unificados, React mergea estos, utilizando el setState de esta manera:

        spread operator sirve para copiar lo que había en el estado actual, y después pisamos solo lo que queremos actualizar

        setData({...data, name: 'nuevo nombre'})

    55. Updating State That Depends On The Previous State
        Cuando actualizamos el estado como antes, es una mejor practica, hacer esto:

        recibe el snaptshoot previo, 
            setData((prevState) => {}, {
                return {
                    ...prevState, 
                    title: 'nuevo titulo'
                }
            })
        
        Dice que si usas el primer approach, y estás actualizando varios estados, podes llegar a tener un estadio "desactualizado". De la otra manera, React garantiza que siempre sera el último snaptshoot y que va a estar correctamente actualizado.

        Esto siempre usarlo si tu state update depende del estado previo, sino no es necesario.

        De todas maneras el se va a manejar con estados separados porque prefiere ese approach.

    56. Handling Form Submission
        La mejor manera de handlear el submit no es poner el handler en el submit, sino en el onSubmit de la etiqueta form.

        Como el form esta preparado par que al submitir envie información a un backend, x ej, hay que hacer si o si preventDefault para evitar esto.

    57. Adding Two-Way Binding
        Significa que va a estar bindeado de dos maneras, porque, el input en este caso, handlea el evento que cambia el estado y a la vez utiliza la propiedad actualizada en dicho estado.

        Una vez que se submite, hay que limpiar los inputs, reinicializando sus estados a vacio.

    58. Child-to-Parent Component Communication (Bottom-up)
        Explica como hacer un handler de saveExpenses por ejemplo, desde un padre, a un hijo y que el hijo setee el estado del padre mediante la función, entonces por ej.

        App 
            handlerAddExpense
                <NewExpense onAddExpense={handlerAddExpense} />
                    dentro de NewExpense tiene la funcion para guardar y se la pasa al hijo
                    handlerSaveExpense
                    <ExpenseForm onSaveExpense={handlerSaveExpense} />
                        este setea el estado y lo "levanta"

        Explicación vieja para class components:
            en el padre, al hijo embebido, le generamos un atributo donde le podemos pasar un metodo, entonces en el archivo del hijo, usando prop podemos utilizarlo.

            o sea, el hijo termina usando un metodo que esta en el padre.

            Si necesitamos pasar parametros hay que usar bind.

            this.metodo.bind(this, param)

            si en vez de usar esa manera, usamos una funcion de flecha anonima, tenemos que tener en cuenta que cuando escribimos la función en una linea:
                onClick={() => this.metodo()}

                adelante del this, si bien no lo pone, hay un RETURN.

            Idealmente es mejor usar bind, porque la función anonima es ineficiente.

    59. Lifting The State Up
        "levantando el estado"

        basicamente el punto anterior, pasar el estado del hijo al padre.

    Assignment 2: Time to Practice: Working with Events & State
        TODO:

    60. Controlled vs Uncontrolled Components & Stateless vs Stateful Co…60. Controlled vs Uncontrolled Components & Stateless vs Stateful Components

        Functional (Stateless) vs class (Stateful) Components
        La mayoria de las veces vamos a usar funciones stateless, las que reciben props.

        La mayor parte de la app, no debería cambiar el estado de la aplicación, se supone que solo va a cambiar en ciertos componentes,
            conocidos como "contenedores" Statefull Components. ej app.js
            
    Quiz 2: Learning Check: Working with Events & State
        TODO:

    61. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/04-react-state-events

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 5: Rendering Lists & Conditional Content

    62. Module Introduction
        ...

    63. Rendering Lists of Data

        Explicación vieja, aplica acá igual...
                .map mapea elementos en un array dado (en este caso "elArray"), ejecuta un metodo en cada elemento del array
            el metodo/funcion, es pasado a mapa dentor de los ().
            - .map retorna un nuevo array, react lo que intenta hacer al retornarlo es renderizarlo otra vez en el DOM (si es un JSX valido)

        esa función que se le pasa a map, se ejecuta en cada elemento del array.
        map tiene un segundo parametro que es el index del elemento.

        {this.state.elArray.map(elementoDelArray => {
            // Lo que quiero mapear dentro de cada elemento.
            return <Person name="person.name" age="person.age" />;                                    
        })}

    64. Using Stateful Lists


        Explicación vieja:

        deletePersonHandler = (personIndex) => {
            const persons = this.state.persons; // Me guardo el array de personas.
            persons.splice(personIndex, 1); // Splice, sirve para eliminar elementos del array, acá le decimos que elimine 1 solo, y un index en particular.
            this.setState({persons: persons})
        }

        {this.state.elArray.map( ( elementoDelArray, index ) => {
            return <Person click={this.deletePersonHandler} name="person.name" age="person.age" />;
        })}

    65. Understanding "Keys"
        React actualiza todos los elementos y los reordena cuando no tiene una key, porque no sabe bien que actualizar, hasta podría perderse información, se soluciona agregandole una key a lo elementos jsx.
        en key o usamos un id especifico o usamos el index del array que estamos recorriendo

        Explicación vieja:
         React exige escribir el elemento key, ya que esto le deja comparar el dom virtual con el dom real, y de esta manera identifica que elemento cambió y debe actualizar y no así toda la lista.
            se tiene que poner el id de los elementos.

            {this.state.elArray.map( ( elementoDelArray, index ) => {
                return <Person click={this.deletePersonHandler} name="person.name" age="person.age" key="person.id" />;
            })}
            
    66. Outputting Conditional Content
    
        por ejemplo para mostrar o dejar de mostrar un div.
        - Hay que usar el operador ternario -
        Dentro de JSX no se puede poner el if comun.

        ej:
        {this.showParrafo === true ?
            <p>hola</p>
        :
        null
        }

        o 

        {this.showParrafo === true && <p>hola</p>}

        significa que o muestro o el parrafo o no muestro (renderizo nada)

        Explicación vieja que suma:
        Dentro de render, antes de retornar algo, podemos poner variables javascript, ya que ahí podemos usar js normalmente.

        ej:

        render (){
            let person = null;

            if(this.person == null) {
                person = ( // esto es como crear un elemento
                    metemos el html aca que queremos ocultar o no
                );
            }

            return (
                html..
                {person} // person es la variable null o la variable donde guardamos el html a renderizar.
            )
        }

    67. Adding Conditional Return Statements
        retorna el componente antes de procesarlo todo al pedo, o sea, valida antes si tiene elementos el array por ej, y sino retorna un mensaje.

    Assignment 4: Time to Practice: Conditional Content
        TODO:

    68. Demo App: Adding a Chart
        https://github.com/academind/react-complete-guide-code/blob/05-rendering-lists-conditional-content/extra-files/ChartBar.css
        https://github.com/academind/react-complete-guide-code/blob/05-rendering-lists-conditional-content/extra-files/Chart.css
        
    69. Adding Dynamic Styles

        Explicación vieja, acá habla de lo mismo.

        Para usar inline styles, se usa javascript en camelCase, ej lo que en css es background-color, aca es backgroundColor o marginLeft, etc.. en el JSX se usa

        Dentro de render ()
        const style = {
            backgroundColor: color,
        }

        <a style={style}></a>

    70. Wrap Up & Next Steps
        ...

    71. Fixing a Small Bug
        The demo application has a small bug at the moment: When adding multiple values, those values are added as strings instead of numbers.

        Fixing it is easy though, simply make sure you enforce a number conversion:

        In ExpenseForm.js, just change

        const expenseData = {
        title: enteredTitle,
        amount: enteredAmount,
        date: new Date(enteredDate),
        };
        to

        const expenseData = {
        title: enteredTitle,
        amount: +enteredAmount,
        date: new Date(enteredDate),
        };
        in the submitHandler function.

    Quiz 3: Learning Check: Outputting Lists & Conditional Content
        TODO: 

    72. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/05-rendering-lists-conditional-content

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Sección 6: Styling React Components
    Cualquier cosa reveer porque apenas chequee xq deje las explicaciones viejas

    73. Module Introduction
        ...

    74. Setting Dynamic Inline Styles

        Explicación vieja, igual aplica acá:

        render () {
            // Agrega esto
            const style = {
                backgroundColor: 'green',
                color: 'white',
                font: 'inherit',
                border: '1px solid blue',
                padding: '8px',
                cursor: 'pointer'
            }

            let persons = null;

            if ( this.state.showPersons ) {
            persons = (
                <div>
                {this.state.persons.map((person, index) => {
                    return <Person
                    click={() => this.deletePersonHandler(index)}
                    name={person.name}
                    age={person.age}
                    key={person.id}
                    changed={(event) => this.nameChangedHandler(event, person.id)} />
                })}
                </div>
            );

            style.backgroundColor = 'red'; // Agrega esto
        }

    75. Setting CSS Class Dynamically

        // Agrega las clases:

        App.css
            .red {
                color: red;
            }

            .bold {
                font-weight: bold;
            }

        App.js
            // Esto usa las clases que declaramos y las une con un espacio en el medio.
            let classes = ['red','bold'].join(' ');

            return (
                <div className="App">
                    <h1>Hi, I'm a React App</h1>
                    <p className={classes}>This is really working!</p>

    76. Introducing Styled Components
        npm install --save styled-components

        import syled from 'styled-components';
        const Button = styled.button`` -> feature: que se llama tacked templates. button es una función o metodo, dentro de los ticks, podes pasar texto.

        Los metodos retornan un componente de react.

        En vez de:
        <div className="Person" style={style}">

        Haces:
        styled.div``
            width: 60%;
            margin:  16px auto;

        pero, es mejor, crear un nuevo COMPONENTE, de esta manera, que es especifica para este framework, ya que recordemos, los metodos, retornan un componente.:

        const StyledDiv = styled.div`
            width: 60%;
            margin:  16px auto;`;

        Esto después lo usamos así:
        <StyledDiv>
        </StyledDiv>

    77. Styled Components & Dynamic Props
        Para pasarle props y cambiar su estilo, dinamicamente, simplemente le pasamos como cualquier otro componente, mediante un nombre de prop y un valor. Después dentro de los backteacks, usamos por ej:

        <StyledButton alt="this.state.button">

        const StyledButton = styled.button`
            background-color: ${props => props.alt ? 'red' : 'green' }
        `;

        Todo esto es javascript, no react, por eso usando los backteacks, se puede usar interpolación de cadenas y a su vez el package hace la magia de poder usar props.

    78. Styled Components & Media Queries (antes este y el prox hablaban de radium)
        TODO: 

    79. Using CSS Modules
        TODO: 
        
    80. Dynamic Styles with CSS Modules
        TODO: 

    81. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/06-styling

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 7: Debugging React Apps

    82. Module Introduction
        ... 

    83. Understanding React Error Messages
        Como ver en la consola el error y en que linea esta.

    84. Analyzing Code Flow & Warnings
        Muestra como seguir un error a partir de la consola de desarrollador.

    85. Working with Breakpoints
        Muestra como buscar en la solapa sources los componentes y poner Breakpoints desde la consola...

    86. Using the React DevTools
        Instala la extensión de chrome, muestra la solapa Components en la consola de Chrome.

        Del lado derecho abajo de todo, en negrita dice "rendering by", muestra el componente seleccionado y quien lo renderizo, tener en cuenta eso.
        
        se puede buscar componentes, se puede cambiar el tema a dark, desde el icono de configuración.

    87. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/07-debugging

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 8: Time to Practice: A Complete Practice Project - TODO:

    88. Module Introduction
        ...

    89. Adding a "User" Component

    90. Adding a re-usable "Card" Component

    91. Adding a re-usable "Button" Component

    92. Managing the User Input State

    93. Adding Validation & Resetting Logic

    94. Adding a Users List Component

    95. Managing a List Of Users via State

    96. Adding The "ErrorModal" Component

    97. Managing the Error State

    98. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/08-practice-project

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 9: Diving Deeper: Working with Fragments, Portals & "Refs"

    99. Module Introduction
        ...

    100. JSX Limitations & Workarounds
        Que no se puede retornar mas de un elemento, ni tener mas de un root.

        Soluciones: wrappear los elementos a la misma altura con un div, un fragment, o cualquier otro elemento sirve. También podemos wrappear los elmentos en un array y separar los componentes por comas, 
        también hay que agregarles key, para que react pueda identificar bien los componentes.

        IMPORTANTE: El problema es que si abusas de los divs, el tree termina lleno de divs que no tienen sentido.

    101. Creating a Wrapper Component
        SOLUCIÓN: Para solucionar el problema anterior crea un componente Wrapper, dentro de una carpeta Helper. Y el componente retorna props.children. Ahora si se revisa el dom, no hay components divs demas al pedo.

    102. React Fragments
        Tambiénn podemos reemplazar el de App con <> o Fragment

    103. Introducing React Portals
        Comenta que tener un modal en una sección o algo así, considerando que ocupa toda la app no es buena practica. O sea, el problema es que este nesteado con otros elementos cuando no debería ser así.

        Es malo para la accesibilidad, es como hacer un boton con un div

        Para esto hay que usar React Portal, para mantener la estructura, pero que al reflejarlo en el DOM real, este por fuera de todo.

    104. Working with Portals
        lo que hace es crear un div a la misma altura que root, en el index.html con un id especifico donde se va a renderar el modal, spinner, etc, y con portal es donde vas a decirle que tiene que ir ahí.

        ReactDOM.createPortal(<Backdrop onConfirm={props.onConfirm} />, document.getElementById('backdrop-root'))

        Es como cuando se renderiza root, pero con portal...

    105. Working with "ref"s

        refs = reference
        useRef se puede usar solo en functional components.

        sirve para conectar cuan cualquier elemento html

        import React, { useRef } from 'react'

        const nameInputRef = useRef(); // un objeto con el 'current value' valor actual del elemento. se guarda el elemento html ahí, el verdadero nodo del dom, lo recomendado es dejar que react maneje el dom, pero leer info nada mas, no habría problema para usar ref.
        
        <input id='userName' ref={nameInputRef} />

        console.log(nameInputRef.current.value) // si escribis en el input, se loguea lo que pusiste

        elementos reales del DOM, 


        Elimina los state que seteaban y servian para leer la info del estado del input, value y onchange también.

        Como no tenes mas el useState, para limpiar los inputs, hace esto:
        nameInputRef.current.value = '' 


        RARAMENTE SE MANIPULA EL DOM ASÍ.-

    106. Controlled vs Uncontrolled Components
        Si accedemos a los valores con ref, son componentes controlados, -un controlled components- porque no los maneja react.
        
        por ende, los controlados, son los que sí maneja react en cuanto al estado.

    107. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/09-fragments-portals-refs

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 10: Advanced: Handling Side Effects, Using Reducers & Using the Con…Section 10: Advanced: Handling Side Effects, Using Reducers & Using the Context API

    108. Module Introduction
        ...

    109. What are "Side Effects" & Introducing useEffect
        
        Main job de react: 
            No nos olvidemos que nuestros componentes/react library, evaluar jsx, reaccionar a un cambio en un input, sirve para renderizar, re-renderizar la ui, etc cuando lo necesitamos..

        Un efecto o side effect es:    
            por ejemplo, enviar un request, setear estados, manejar timers... 
            tienen que pasar por fuera de tu componente, 

            Para esto se usa useEffect(), sirve para:

                import React, { useEffect } import 'react'

                Toma una función que corre en cada ciclo de renderizado, si las dependencias cambian, no cuando se re-renderiza e lcomponente
                    useEffect(() => {
                        // ...código
                    },[dependencias])

    110. Using the useEffect() Hook

        Muestra como usar localStorage, para simular que estas logueado a una pseudo app que solo tiene un login.
        Si dejamos el código que hace la validación se va a generar un loop infinito, para eso usamos useEffect.

        useEffect(() => {
            const storedUserLoggin = localStorage.getItem('isLoggedIn')

            if(storedUserLoggin === '1'){
                setIsLoggedIn(true)
            }
        },[])

        Que haga algo solo la primera vez. Se pone un array vacio [] y corre una sola vez y nunca mas.
            useEffect(() => {

            },[])

        useEffect combina dos:
            componentDidMount y componentDidUpdate.

    111. useEffect & Dependencies
        Cuando se actualiza un estado especifico, lo que hay que hacer es pasarlo como dependencia, para que useEffect se vuelva a ejecutar para que se reevalue el estado
        
            Lo que hay que hacer sería lo siguiente:

            useEffect(() => {
                ...
            },[isLoggedIn])

        IMPORTANTE: No es necesario pasar las funciones que setean los estados ya que eso nunca cambia, solo hay que pasar sus estados y solo los que se usen dentro de useEffect.

    112. What to add & Not to add as Dependencies
        In the previous lecture, we explored useEffect() dependencies.

        You learned, that you should add "everything" you use in the effect function as a dependency - i.e. all state variables and functions you use in there.

        That is correct, but there are a few exceptions you should be aware of:

        You DON'T need to add state updating functions (as we did in the last lecture with setFormIsValid): React guarantees that those functions never change, hence you don't need to add them as dependencies (you could though)

        You also DON'T need to add "built-in" APIs or functions like fetch(), localStorage etc (functions and features built-into the browser and hence available globally): These browser APIs / global functions are not related to the React component render cycle and they also never change

        You also DON'T need to add variables or functions you might've defined OUTSIDE of your components (e.g. if you create a new helper function in a separate file): Such functions or variables also are not created inside of a component function and hence changing them won't affect your components (components won't be re-evaluated if such variables or functions change and vice-versa)

        So long story short: You must add all "things" you use in your effect function if those "things" could change because your component (or some parent component) re-rendered. That's why variables or state defined in component functions, props or functions defined in component functions have to be added as dependencies!

        Here's a made-up dummy example to further clarify the above-mentioned scenarios:

        import { useEffect, useState } from 'react';
        
        let myTimer;
        
        const MyComponent = (props) => {
        const [timerIsActive, setTimerIsActive] = useState(false);
        
        const { timerDuration } = props; // using destructuring to pull out specific props values
        
        useEffect(() => {
            if (!timerIsActive) {
            setTimerIsActive(true);
            myTimer = setTimeout(() => {
                setTimerIsActive(false);
            }, timerDuration);
            }
        }, [timerIsActive, timerDuration]);
        };
        In this example:

        timerIsActive is added as a dependency because it's component state that may change when the component changes (e.g. because the state was updated)

        timerDuration is added as a dependency because it's a prop value of that component - so it may change if a parent component changes that value (causing this MyComponent component to re-render as well)

        setTimerIsActive is NOT added as a dependency because it's that exception: State updating functions could be added but don't have to be added since React guarantees that the functions themselves never change

        myTimer is NOT added as a dependency because it's not a component-internal variable (i.e. not some state or a prop value) - it's defined outside of the component and changing it (no matter where) wouldn't cause the component to be re-evaluated

        setTimeout is NOT added as a dependency because it's a built-in API (built-into the browser) - it's independent from React and your components, it doesn't change

    113. Using the useEffect Cleanup Function
        useEffect(() => {
                ...

            return () => {
                console.log('CLEANUP')
            }; // se ejecuta antes de todo el código de useEffect, sirve para "limpiar"
        },[isLoggedIn])

        o sea, la primera vez que se renderiza el componente no, sino las proximas.

        por ejemplo, lo mostro con un timer, y  la cleanup se ejecutaba constantemente para limpiar el timer y recién cuando dejó de escribir y terminó el timer, se volvió a renderizar el documento.

    114. useEffect Summary
        TODO: 
        
    115. Introducing useReducer & Reducers In General
        Cuando tenes estados mas complejos, sirve como reemplazo de useState.

        Recomienda usarlo para cuando un estado depende de otro o por ejemplo para hacer validaciones de un estado especifico, como el email, realizar validaciones mediante acciones.

        Siempre recomienda setear el estado pasando el parametro prevState porque es la unica manera que te asseguras que el estado siempre este actualizado a lo ultimo, porque a veces puede pasar que react no actualice los estados a tiempo.
         
    116. Using the useReducer() Hook
        retorna dos valores, como setState

        const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);

        state = 
            el snapshot del estado que se usa en el ciclo de re-evaluación del re-renderizados

        dispatchFn = 
            una funcion que puede ser usada para dispatchear una nueva acción, por ej triggerear un update del estado.
        
            esa acción, va a ser usada por la primer función pasada a useReducer, en este caso reducerFn, recibe el último snaptshopt y debería retornar el nuevo estado actualizado.

        initialState = 
            el estado inicial

        initFn = 
            una funcion para setear el estado inicial 

            // se puede crear afuera, porque react automaticamente se la pasa al reducer cuando se renderiza el componente.

            const emailReducer = (state, action) => {

                switch(action){
                    case 'USER_INPUT': 
                        return { value: '', isValid: action.val.includes('@') }
                    case 'INPUT_BLUR'
                        return { value: Action.val, isValid: false }
                    default:
                        return { value: Action.val, isValid: false }    

            } 

            //dentro del componente:
            const [emailState, dispatchEmail ] = useReducer(emailReducer);

            const emailChangeHandler = (event) => {
                distpatchEmail({type: 'USER_INPUT', val: event.target.value})

                setFormIsValid(
                    event.target.value.includes('@')
                )
            }

            const validateEmailHandler = () => {
                dispatcEmail({type: 'INPUT_BLUR'})
            }

            enteredEmail lo cambia por emailState.isValid

    117. useReducer & useEffect
        Destructurando propiedades para que SOLO CAMBIE EL ESTADO, SI ESTAS CAMBIAN, por ende no se re-renderiza todo cuando el objeto cambia. 
        
        A  la propiedad destructurada se le puede poner un alias
        const { isValid: emailIsValid } = emailState;

        También simplemente se le podría pasar como dependenca a useEffect, emailState.isValid y listo

    118. Adding Nested Properties As Dependencies To useEffect
        In the previous lecture, we used object destructuring to add object properties as dependencies to useEffect().

        const { someProperty } = someObject;
        useEffect(() => {
        // code that only uses someProperty ...
        }, [someProperty]);
        This is a very common pattern and approach, which is why I typically use it and why I show it here (I will keep on using it throughout the course).

        I just want to point out, that they key thing is NOT that we use destructuring but that we pass specific properties instead of the entire object as a dependency.

        We could also write this code and it would work in the same way.

        useEffect(() => {
        // code that only uses someProperty ...
        }, [someObject.someProperty]);
        This works just fine as well!

        But you should avoid this code:

        useEffect(() => {
        // code that only uses someProperty ...
        }, [someObject]);
        Why?

        Because now the effect function would re-run whenever ANY property of someObject changes - not just the one property (someProperty in the above example) our effect might depend on.

    119. useReducer vs useState for State Management
        usar reducer cuando el sentido de useState sea medio al pedo, y tengas bugs o comportamientos no intencioados.
        
        useState
            herramienta principal
            bueno para piezas independientes de info/estado
            bueno si las actualizaciones de estado son faciles y limitadas a unos pocos updates.

        useReducer
            bueno si necesitas "mas poder"
            si tenes updates de estado mas complejos
            considerarlo si tenes data/estados  relacionada
            
    120. Introducing React Context (Context API)
        * this.context no se usa mas, se debe usar esta api. React.createContext + useContext

        PROVIDER: se crea el context para que los componentes después, lo puedan CONSUMIR.
            - React create context, nos permite inicializar nuestro contexto con un valor inicial, puede ser cualquiera cosa, obj, array, etc. También se inicializa para poder usar el intellisense, pero generalmente la inicialización no se utiliza salvo que no se pase nada al atributo value del componente.

            - Crete context es un "objeto global" de javascript. O sea, en realidad no es que es un objeto global,
            sino que vos decidis donde se va a aplicar.

            - En el contexto tengo que guardar todo lo que quiero acceder desde mis diferentes componentes.

            - Con nuestro nuevo componente, en este caso authContext, tenemos que envolver, los componentes, que querramos que tengan acceso a esta información.

        CONSUMER:
            - Se debe importar el context, y en el return, debemos utilizar el componente, englobando los componentes que necesitan esa info, pero con <AuthContext.Consumer> ver ej mas abajo:
            - No toma JSX como un hijo, pero si una función, ver ej de como realizar esto.
            - Se utiliza en el componente que este lo mas abajo posible, ya que sino tenemos que andar pasando cosas por props y justamente esa no es la idea.

    121. Using the React Context API
        Crea una carpeta context (porque a el le gusta hacerlo así): de esta manera todos los componentes que esten envueltos en el componente AuthContext, van a "escuchar" las actualizaciones sobre los estados isAuth y login.

        auth-context.js
            import React, { useState } from 'react';

            export const AuthContext = React.createContext({
                isAuth: false,
                login: () => {}
            });

            const AuthContextProvider = props => {
                const [isAuthenticated, setIsAuthenticated] = useState(false);

                const loginHandler = () => {
                    setIsAuthenticated(true);
                };

                return (
                    <AuthContext.Provider
                    value={{ login: loginHandler, isAuth: isAuthenticated }}>
                        {props.children} // De esta manera decis que a este componente se le puede pasar cualquier otro componente, es un wrapper.
                    </AuthContext.Provider>
                );
            };

            export default AuthContextProvider;

        index.js

            <AuthContextProvider>
                <App />
            </AuthContextProvider>

        app.js
            En los componentes funionales, el contexto no se puede utilizar, deberíamos convertirlos a clases, pero, para no hacer eso, podemos usar el hoook useContext.

            import React, { useContext } from 'react';

            import Ingredients from './components/Ingredients/Ingredients';
            import Auth from './components/Auth';
            import { AuthContext } from './context/auth-context';

            const App = props => {
                const authContext = useContext(AuthContext);

                let content = <Auth />;
                if (authContext.isAuth) {
                    content = <Ingredients />;
                }

                return content;
            };

            export default App;

        Auth.js
            import React, { useContext } from 'react';

            import Card from './UI/Card';
            import { AuthContext } from '../context/auth-context';
            import './Auth.css';

            const Auth = props => {
            const authContext = useContext(AuthContext);

            const loginHandler = () => {
                authContext.login();
            };

            return (
                <div className="auth">
                    <Card>
                        <h2>You are not authenticated!</h2>
                        <p>Please log in to continue.</p>
                        <button onClick={loginHandler}>Log In</button>
                    </Card>
                </div>
                );
            };

            export default Auth;

        IMPORTANTE: lo que se cambie en ese contexto, no va a generar una re-renderización.

    122. Tapping Into Context with the useContext Hook
        
        FUNCTIONAL COMPONENTS
            import AuthContext from 'context/aut-context';
            import React, {useContext} from 'react'

            const authContext = useContext(AuthContext);

            authContext.authenticated

        COMPONENTES BASADOS EN CLASES:

            Como en ComponentDidMount, puede que tengas que hacer un llamado HTTP y necesites el context y ahí no se puede obtener la info como la aprendimos.
            A partir de react 16.6 hay una variable estatica contextType.

            static contextType = authContext;

            Esto habilita a que detrás de escena, el metodo ComponentDidMount, se comunique con la variable estatica, ya que ahora tenes dentro del metodo:
            this.context.login por ej.
            this.context.authenticated
            También podemos modificar el elemento AuthContext.Consumer por this.context.authenticated

    123. Making Context Dynamic
        explica que se pueden agregar funciones al contexto (mas arriba hay un ejemplo)
        authContext.login();

    124. Building & Using a Custom Context Provider Component
        Le mete mas funciones al contexto que ya había creado.

    125. React Context Limitations
        No esta optimizado para muchos cambios por segundo
        Tampoco debe ser usado para reemplazar todas las comunicaciones entre los componentes.

    126. Learning the "Rules of Hooks"

        - Arrancan con useNombreDelHook
        - Podemos llamarlo con un estado inicial o no.
        - Se crea un estado que se maneja "detras de escena" por React, que sobrevive ciclos de re-renderizado
        - Depende lo que retornemos, podemos tener por ej: 
            una matriz con dos elementos, el primero es un puntero a tu estado y es el segundo es  una función de update del estado.

        Hay dos reglas importantes que se aplican a todos los estados:
            1) Los hooks, solo se deben usar en componentes funcionales (functional components) o dentro de nuestros propios hooks personalizados.
            2) No podes usar un hook en una función anidada, siempre es en el componente root. Para que quede claro, esto no se puede hacer:

            const unaFuncion = () => {
                useState() -> usarlo acá adentro.
            }

    127. Refactoring an Input Component
        Crea un component custom de Input.
        
    128. Diving into "Forward Refs"
        Para poder hacerle focus a los input (ya que no viene con react), tenemos que usar useRef para acceder al DOM real, y utilizarlo en ambos inputs, el problema es que no se puede hacer eso para ambos.

        Por eso hay que generar una función imperativa, basicamente es porque si bien focus no se puede usar esta ordenando que se use mediante estas tecnicas.

        hay que importar useImperativeHandler

        en el componente aparte de props, pasar ref y envolverlo en React.forwardRef, se usa para decir este es un componente que puede utilizar ref.

        1 arg: ref
        2 arg: la función anonima, va a devolver un objeto con información que se va a poder usar desde el exterior. 

        useImperativeHandler(ref, () => {
            return {
                focus: active()
            }
        }) 

        reemplazamos donde se usa props.current.activate por .focus (aunque le podríamos haber puesto activate o pedo a la prop que retorna useImperativeHandler)

        Solo usar en casos muy especiales, ya que no se recomienda su uso.

    129. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/10-side-effects-reducers-context-api

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 11: Practice Project: Building a Food Order App

    130. Module Introduction

    131. Starting Setup

    132. Adding a "Header" Component

    133. Adding the "Cart" Button Component

    134. Adding a "Meals" Component

    135. Adding Individual Meal Items & Displaying Them

    136. Adding a Form

    137. Fixing Form Input IDs

    138. Working on the "Shopping Cart" Component

    139. Adding a Modal via a React Portal

    140. Managing Cart & Modal State

    141. Adding a Cart Context

    142. Using the Context

    143. Adding a Cart Reducer

    144. Working with Refs & Forward Refs

    145. Outputting Cart Items

    146. Working on a More Complex Reducer Logic

    147. Making Items Removable

    148. Using the useEffect Hook

    149. Module Resources

# Section 12: A Look Behind The Scenes Of React & Optimization Techniques

    150. Module Introduction
        ...

    151. How React Really Works
        mira el arbol actual y como debería estar, reactDOM recibe las diferencias y manipula el dom real

        los componentes son re-evaluados cuando las props, estado o context cambian
        los cambios en el real dom se hacen solo por las diferencias entre las evaluciones que se realizan en memoria y son baratas de realizar, no como en el real dom.

        react tiene el dom virtual que maneja diferenciación.
        evaluación previa -> evaluación actual 
        <h1></h1>               <h1></h1>
                                <p> this is new</p>
                                Acá los cambios son requeridos y se debería insertar en el dom el elementp p, el resto queda sin cambios.

    152. Component Updates In Action
        muestra lo que explicó antes

    153. A Closer Look At Child Component Re-Evaluation
        Los hijos de un componentes van a ser siempre re-evaluados, pero si no hubo cambios en su estado o prop, no hacen nada.

        Si bien no hay problema, el tema es que se están re-evaluando cosas que no cambiaron y se pierde tiempo y se usan recursos en esa re-evalución.

    154. Preventing Unnecessary Re-Evaluations with React.memo()
        Solo importaría en apss grandes, sino no vale la pena hacer esto.

        Lo que hace es tomar un snapshot del componente y lo re-renderiza, si y solo si, el input cambia.

        export default React.memo(DemoOutput);

        La optimización igual lleva un costo, ya que también realiza comparaciones para saber si es necesario o no re-renderizar el componente.

        Solo es realmente aplicable en grandes apps, y solo funciona con datos primitivos, ya que si cambia una función, se re-crea y genera otro puntero en memoria, para eso habíar aque usar useCallback()

    155. Preventing Function Re-Creation with useCallback()

        Sirve para que no se re-creen las funciones, porque cuando se recrean, son funciones diferntes en memoria, dió el ejemplo de obj1 y objt2 que no son iguales, salvo que uno pise al otro.-

        useCallback: Nos permite envolver nuestra función y pasarle un 2do argumento con las dependencias del argumento, como nuestra funcion setUserIngredients, no tiene dependencias, entonces le especificamos a useCallback un array vacio, como useeffect.

         Lo que hace useCallback es cachear la función y que sobreviva a las re-renderizaciones, o sea, no se va a recrear la funcion cuando el componente se re-renderice.

         Si bien elimina el loop infinito en la solapa de network verifica porque hay 2 peticiones.

         Una es para obtener los ingredientes, la otra es desde ingredientes.

    156. useCallback() and its Dependencies
        Las funciones son closures, cuando una función es definida, javascript lockea todas las variables dentro de la misma, por ende la proxima vez que se ejecute, esa variable que tenía a dentro es la que va a usar usada, por ende useCallback, no re-evalua la función y si era una variable de estado la que cambió, no va a volver a cambiar porque permanece con el estado que se creo la primera vez, para eso hay que usar useCallback con dependencias, como useEffect

    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

    157. A First Summary
        TODO: 

    158. A Closer Look At State & Components
        useState atacha al componente un estado, y se asegura que el valor default sea tomado solamente la primera vez.

    159. Understanding State Scheduling & Batching
        React programa un cambio de estado, y lo hace, puede pasar que se estén realizando muchas tareas en el mismo momento entonces react pospone este cambio de estado.

        Los updates se realizan uno tras otro, siempre en orden. Por eso siempre recomiendan que al actualizar un estado usen prevState

        setShowParagraph((prevShowParagraph) => !prevShowParagraph)

        ya que es la manera mas segura de hacerlo.

        IMPORTANTISIMO: Los valores de los estados cambiados recién se ven reflejados cuando el componente se re-renderiza, no en el momento. 

    160. Optimizing with useMemo()

        Viejo:
        Cuando el componente donde se aloja una función se re-renderiza, la función se vuelve a recrear, es por eso que necesitamos usar useCallback, para que no se recree nuevamente. No es que se  ejecuta, se vuelve a crear.

        useMemo es como useCallback pero con un valor.

        Lo que hace es cortar el componente IngridientList y usa useMemo. Lo que hace es que React memoriza el valor que queres retornar, en este caso es un component.

        useMemo también tiene segundo parametro como useCallback, solo que le dice a React, cuando debe volver a ejecutar la función para crear un nuevo objeto que debe memorizar, entonces le pasamos las dependencias para que sepa cuando ese componente se tiene que re-renderizar, que es cuando cambian alguno de los dos, un estado y una prop.

        A veces hay que analizar si vale la pena usar react.memo o useCallback o useMemo, porque capaz que son cosas chicas y no valenla pena, porque el costo re-renderizado al de chequeo constante puede ser menos.

        El ejemplo lo muestra con un array que no cambia nunca, pero al recrear la función un array nuevo se recrea, por ende en memoria, por ende re-renderiza todo.

    161. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/12-a-look-behind-the-scenes

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 13: An Alternative Way Of Building Components: Class-based Components
    TODO: 

    162. Module Introduction

    163. What & Why

    164. Adding a First Class-based Component

    165. Working with State & Events

    166. The Component Lifecycle (Class-based Components Only!)

    167. Lifecycle Methods In Action

    168. Class-based Components & Context

    169. Class-based vs Functional Components: A Summary

    170. Introducing Error Boundaries

    171. Module Resources

# Section 14: Sending Http Requests (e.g. Connecting to a Database)
    TODO: 

    172. Module Introduction
        ...

    173. How To (Not) Connect To A Database

    174. Our Starting App & Backend

    175. Sending a GET Request

    176. Using async / await

    177. Handling Loading & Data States

    178. Handling Http Errors

    179. Using useEffect() For Requests

    180. Preparing The Project For The Next Steps

    181. Sending a POST Request

    182. Wrap Up

    183. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/14-sending-http-requests

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 15: Building Custom React Hooks

    184. Module Introduction
        ...

    185. What are "Custom Hooks"?
        Son solo funciones regulares, como useState, pero son funciones que contienen logica reusable statica,
        puede usar otros hooks.

        Info vieja mas completa:

        Nos ayuda a trabajar con nuestros componentes de una manera mas eficiente.

        1) Functional:
            Props in, JSX out
            Great for Presentational
            Focused on one/few purpose(s)

        2)  Funcional With Hooks
            Nos permite trabajar con functional components only.
            Hooks, reemplaza las funcionalidades de las clases (el manejo de estado)
                (que por eso las teníamos que usar, si bien podes crear clases, no es obligación.

        3) Class-based:
            Uses props and state
            Business logic goes in here
            Orchestates components.
            Lifecycle hooks (can be hard to use)

        - Para usar uno u otro, hay que convertirlos o desconvertirlos y es bastanta molesto.

        React hooks:
                Estan en React desde la versión 16.8
                Se llaman así porque "enganchas" un "function component", con cierta funcionalidad.
                simplemente funciones javascript.
                Los nombres de las funciones de React hooks arrancan con useAlgo()
                Con Hooks, podes hacer que todo sean functional components, no necesitas mas clases.

            Se pueden usar:
                dentro de funcional components.
                dentro de otros hooks.
                Son reutilizables e independientes de cada componente.

            También podemos:
                escribir nuestros propios hooks.
                Compartir la logica completa o sin estado entre multiples componentes.

            No son - no tienen que ver:
                No se pueden reemplazar los metodos de ciclo de vida con react hooks.

        La idea de los hooks, es que vos podes exponer cierta (posiblemente stateful funcionalities) a functions components, como manejar el estado, como el ciclo de vida de los componentes.

        
            Lifecycle hooks, son sinonimo de los metodos de ciclo de vida y solo se pueden usar en componentes basados en clases.

    186. Creating a Custom React Hook Function
        Verifica que se repite código tanto en FordwardCounter como BackwardComponent, entonces extrae todo lo que se repite a un hook, y usa en estos el hook, tomando solo lo que retorna el hook, el counter.

    187. Using Custom Hooks
        los estados que esten dentro del hook, van a estar atachado a cada componente que use el hook, pero son diferentes estados, no el mismo.-

        en el componente simplemente se usa una variable y el hook para usar la informacion de la misma.

    188. Configuring Custom Hooks
        Le pasa props al hook para ciertas configuraciones, verifica si se usa en useEffect y le pasa la nueva dependencia.

    189. Onwards To A More Realistic Example
        Se fija que otras cosas se repiten y si se pueden hacer uno o dos hooks para que no haya código repetido.

        Reemplaza el hook en doned lo neceistaba.
        
    190. Building a Custom Http Hook
        Explicación vieja que es exactamente para este cap..

        Crea una carpeta hooks y un el archivo http.js, crea un custom hooks, siempre hay que arrancar el nombre con useAlgo, va a ser una función, como cualquier otra.
        Podes usar cualquier hook dentro de tu custom hook.

        Si se usa en diferentes componentes, no es que van a compartir los datos, sino que cada componente va a tener un snapshot del hook. O sea que compartis logica, pero no los datos.

        No se importa React, porque no se esta haciendo un componente.

        https.js:
            import { useReducer, useCallback } from 'react';

            const httpReducer = (curHttpState, action) => {
                switch (action.type) {
                        case 'SEND':
                            return {
                                loading: true,
                                error: null,
                                data: null,
                                extra: null,
                                identifier: action.identifier
                            };
                        case 'RESPONSE':
                            return {
                                ...curHttpState,
                                loading: false,
                                data: action.responseData,
                                extra: action.extra
                            };
                        case 'ERROR':
                            return { loading: false, error: action.errorMessage };
                        case 'CLEAR':
                            return { ...curHttpState, error: null };
                        default:
                            throw new Error('Should not be reached!');
                }
            };

            const useHttp = () => {
                const [httpState, dispatchHttp] = useReducer(httpReducer, {
                    loading: false,
                    error: null,
                    data: null,
                    extra: null,
                    identifier: null
                })
            };

            const sendRequest = useCallback((url, method, body, reqExtra, reqIdentifer) => {
                dispatchHttp({ type: 'SEND', identifier: reqIdentifer });
                    fetch(url, {
                        method: method,
                        body: body,
                        headers: {
                        'Content-Type': 'application/json'
                        }
                    })
                    .then(response => {
                        return response.json();
                    })
                    .then(responseData => {
                        dispatchHttp({
                            type: 'RESPONSE',
                            responseData: responseData,
                            extra: reqExtra
                        });
                    })
                    .catch(error => {
                        dispatchHttp({
                            type: 'ERROR',
                            errorMessage: 'Something went wrong!'
                        });
                    });
                },
                []
            );

            return {
                    isLoading: httpState.loading,
                    data: httpState.data,
                    error: httpState.error,
                    sendRequest: sendRequest,
                    reqExtra: httpState.extra,
                    reqIdentifer: httpState.identifier
                };
            };

            export default useHttp;

    191. Using the Custom Http Hook
        Lo importa, le pasa los argumentos ncesarios..

    192. Adjusting the Custom Hook Logic
        usa useCallback para el sendRequest, ya que al recrearse de nuevo genera que en useEffect haya un loop infinito.

        o la otra opción es dejar de pasarle el parametro al useHttp, y pasar la función dentro del useEffect, para que no se genere mas ese problema.

    193. Using The Custom Hook In More Components
        https://academind.com/tutorials/function-bind-event-execution/

        Usa el hook en otro componente, y lo configura.

    194. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/15-building-custom-react-hooks

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 16: Working with Forms & User Input
    TODO:

    195. Module Introduction
        ...

    196. Our Starting Setup

    197. What's So Complex About Forms?

    198. Dealing With Form Submission & Getting User Input Values

    199. Adding Basic Validation

    200. Providing Validation Feedback

    201. Handling the "was touched" State

    202. React To Lost Focus

    203. Refactoring & Deriving States

    204. Managing The Overall Form Validity

    Assignment 5: Time to Practice: Forms

    205. Adding A Custom Input Hook

    206. Re-Using The Custom Hook

    207. A Challenge For You!

    208. Applying Our Hook & Knowledge To A New Form

    209. Summary

    210. Bonus: Using useReducer()

    211. Module Resources

# Section 17: Practice Project: Adding Http & Forms To The Food Order App
    TODO: 
    212. Module Introduction

    213. Moving "Meals" Data To The Backend

    214. Fetching Meals via Http

    215. Handling the Loading State

    216. Handling Errors

    217. Adding A Checkout Form

    218. Reading Form Values

    219. Adding Form Validation

    220. Submitting & Sending Cart Data

    221. Adding Better User Feedback

    222. Summary

    223. Module Resources

# Section 18: Diving into Redux (An Alternative To The Context API)

    224. Module Introduction
        ...

    225. Another Look At State In React Apps
        Es un sistema de administración de estado para comonentes cruzados o apps amplias.

        Local State
            Estados que pertenecee a un solo componente.
             Se puede manejar con useState() o useReducer()

        Que es un componente cruzado (cross-componente state)?
            El estado afecta a varios componentes.
            Ej: abrir cerrar modal
            Se requiere props chain / props drilling

        Que es una aplicación amplia (app-wide state)?
            El estado afecta a toda la app, la mayoría de los componentes.
            Ej: la autenticación del usuario
            Se requiere props chain / props drilling

        Tanto el contexto como Redux nos sirve para simplicar el manejo de estado, ahora vemos las diferencias.

    226. Redux vs React Context
        Se pueden usar ambos, pero generalmente se usa uno de los dos.

        Desventajas de Context:
            Setup y administración Compleja para apps empresariales.
            Podes llegar a tener muchos Providers y es un lío
            Performance, porque el context no esta optimizado para cambios de estado de alta frecuencia

    227. How Redux Works
        Alternativa a React Context. 
        Tiene UN SOLO ESTADO CENTRAL para administrar el estado en la aplicación, no necesitamos
        manejar todo el estado todo el tiempo.

        Tenemos data en ese store que vamos a usar en nuestros componentes, por ejemplo el estado de autenticación.
        Los componentes se suscriben a nuestro store y cuando cambia algun dato, el store notifica a los componentes y obtienen solo la data que necesitan.

        Los componentes NUNCA manipulan la data del store directamente, usan reducer functions, que son las que mutan los datos (no es useReducer) es un concepto, toman un input, lo "reducen" y dan el output.

        Como se conectan los componentes con este store?
            Trigger, es una buena palabra, los componentes dispatchean (triggerean) acciones, que describen que se quiere hacer, estas son enviadas al reducer a través del dispatch, y este sabe que van a hacer y reemplazan el estado en el estado central, cuando este se actualiza, los componentes son notificacods.

    228. Exploring The Core Redux Concepts
        Va a recrear la explicación solo con node.js y redux, por lo que el import cambia:

        redux-demo.js
            const redux = require('redux');

            // reducer function, recibe 2 parametros, oldState, distpatchedAction -> retorna un objeto con el nuevo estado. 
            // Tiene que ser una FUNCIÓN PURA, lo que significa es que los inputs, producen el mismo outputs y no hay side effects dentro de la función (no useEffect, https calls, etc)
            // El estado puede ser de cualquier tipo, generalmente son objetos.. se le tiene que dar un valor por default

            const counterReducer = (state = { counter: 0}, action) => {
                return {
                    counter: state.counter + 1;
                }
            };

            // sirve para crear un store..
            const store = redux.createStore(counterReducer); // debe manejar datos, estan determinadas por las reducer functions.
            
            // no tiene parametros, obtiene el último estado.
            const counterSubscriber = () => {
                const latestState = store.getState(); 
                console.log(latestState)
            };

            // espera una suscriber function
            store.suscribe(counterSubscriber);

            // creamos un distpach que envía una acción.
            // un dispatch es un metodo, que envía una acción.
            // una acción, es objeto que tiene una propiedad type (un identificador string)

            store.dispatch({type: 'increment'})

            hasta ahora esto no hace nada, lo seguimos actualizando en la prox clase

    229. More Redux Basics
            Tenemos que manejar dentro del reducer, la acción a realizar

            const counterReducer = (state = { counter: 0}, action) => {
                if(action.type === 'increment') {
                    return {
                        counter: state.counter + 1;
                    }
                }

                if(action.type === 'decrement') {
                    return {
                        counter: state.counter - 1;
                    }
                }

                return state; // retornamos el state por default
            };

            const store = redux.createStore(counterReducer);
            
            const counterSubscriber = () => {
                const latestState = store.getState(); 
                console.log(latestState)
            };

            store.suscribe(counterSubscriber);

            // podemos distpachear mas de una acción
            store.dispatch({type: 'increment'})
            store.dispatch({type: 'decrement'})


            Todo esto es el core de Redux, si bien no lo estamos usando con React, es como funciona y aparte Redux se puede utilizar totalmente si React.-

    230. Preparing a new Project
        Usa el proyecto adjunto, instala redux y react-redux 
        el último package sirve para conectar react applications facilmente con el store, suscribers, etc.

    231. Creating a Redux Store for React
        Crea el mismo store que en la 229

        salvo que esta vez, exporta el store, y conecta la app al store, en App.
        Sigue >

    232. Providing the Store
        import { Provider } from 'react-redux'
        import store from './store/index.js' -> index o caca, da igual el nombre del archivo en el que lo creamos al store.

        <Provider store={store}>
            <App />
        </Provider>

        Se recomienda hacerlo rodeando App, para no tener que andar usando el provider en componentes especificos nesteados.
        Todos los componentes van a poder enviar acciónes.

    233. Using Redux Data in React Components
        para utilizar el valor del store, en el componente que lo queremos acceder, tenemos que usar useSelector.

        import { useSelector } from 'react-redux' 

        // dentro del componente, useSelector espera una función que, recibe por parametro el estado y accede a la data del state que necesitamos.
        
        const counter = useSelector((state) => state.counter)

        Cuando el componente es removido del dom, redux se encarga de limpiar la suscripción.

        IMPORTANTE: si usaramos class componentes, tenemos que importar connect también, para conectar el componente con el store.
        se puede usar también en function componentes, pero no es necesario.

    234. Dispatching Actions From Inside Components
        Para enviar acciones, el ejemplo que hace es generar dos botones, importar useDispatch

        retorna una función que podemos ejecutar (distpachea una acción a nuestro store), dentro del componente:

        import { useSelector, useDispatch } from 'react-redux' 

        const Componente = () => {
            const counter = useSelector((state) => state.counter)
            const distpatch = useDispatch()

            const decrement = () => {
                distparch({type: 'decrement'})
            }

            const increment = () => {
                distparch({type: 'increment'})
            }

            // resto del código...
        }

    235. Redux with Class-based Components
        muestra un ejemplo con class component

        devuelve una función y hay que pasarle el componente.

        Tiene 2 argumentos que son funciones:
        // redux state to props, esas props, van a estar disponibles en el componente, es como useSelector

        const mapStateToProps = state => {
            return {
                counter: state.counter        
            }
        }

        // redux state to props, esas props, van a estar disponibles en el componente, es como useDispatch
        const mapDispatchToProps = dispach => {
            return {
                increment: () => distpach({type: 'increment'})
                decrement: () => distpach({type: 'decrement'})
            }
        }

        connect(mapStateToProps, mapDispatchToProps)(Counter)

        En este caso no es necesario 

        después en el componete de clase, accedes this.props.increment()

        y bindeas las funciones de handler, ya que así funciona en class components.

    236. Attaching Payloads to Actions
        en el mismo dispatch se el agrega el valor que queres que pueda usar esa acción.

        ej:
        distpach({type: 'increment', amount: 10 })

    237. Working with Multiple State Properties
        va a dar un ejemplo con un toggle, agrega una propiedad incial al store

        cuando agregamos una propiedad, aunque no haga a la cuestión en cierta acción, hay que agregarla igual

        const initialState = { 
            counter: 0,
            showCounter: state.showCounter
        }

        const counterReducer = (state = initialState, action) => {
                return {
                    counter: state.counter + 1;
                    showCounter: state.showCounter
                }
            };

        idem al reves:

        if(action.type === 'toggle'){
            return {
                counter: state.showCounter
                showCounter: state.counter
            }
        }

    238. How To Work With Redux State Correctly
        IMPORTANTE: NUNCA PERO NUNCA, MUTAR EL ESTADO ASÍ:. Siempre copiar y crear nuevos objetos.
        
        state.counter++

        SIEMPRE ASÍ:
        const counterReducer = (state = initialState, action) => {
            return {
                counter: state.counter + 1;
                showCounter: state.showCounter
            }
        };

    239. Redux Challenges & Introducing Redux Toolkit
        Para no errarle a los nombres de los tipos de acciones, crear constantes.
        
        Cuando la app se hace enorme, podemos encontrarnos con demasiado código en nuestro store.
        También tenemos que tener cuidado de no cambiar los estados, que se hace mas dificil cuando hay objetos nesteados.
        También se pueden hacer archivos mas chicos, para no tener todo en uno..
        
        Para todo eso esta Redux Toolkit, si lo usas las cosas se pueden poner mas faciles si lo haces...

        :shrek:

    240. Adding State Slices
        desinstalar redux, ya que redux Toolkit ya lo trae.

        npm install @reduxjs/toolkit
        
        import { createSlice } from '@reduxjs/toolkit' -> es mas poderoso que createReducer

        const initialState = { 
            counter: 0,
            showCounter: state.showCounter
        }

        // recibe un objeto, obtenemos un pedazo del estado.- podemos sacar pedazos de nuestro estado en difernetes archivos para mejorar el código.
        // hay que darle un nombre al estado (puede ser cualquier nombre)
        // agregar el valor inicial
        // reducers, las funciones que queremos exponer, reciben el stado por parametro y la acción se podría agregar como segundo parametro, pero no es necesario,
        redux entiende cual es el que necesita la info.

        // SI BIEN NO DEBEMOS MANIPULAR EL ESTADO ASÍ, en funciones como esta, PODEMOS.- Redux usa Emmer, que detecta este tipo de cosas y clona, copia, 
        overridea, etc por nosotros que somos unos pelotudos a cuerda y le pifiamos.
        LO HACE INTERNAMENTE, MAGIC.

        // en increase por ej que necesita el extra payload, si hay que poner la acción pero en los que no, no es necesario ponerla, como antes...
        AGUANTE REDUX TOOLKIT.-

        createSlice({
            name: 'counter',
            initialState: initialState,
            reducer: {
                increment(state) {
                    state.counter++ 
                },
                decrement(state) {
                    state.counter--
                },
                increase(state, action) {
                    state.counter = state.counter + action.amount
                },
                toggleCounter(state) {
                    state.showCounter = !state.showCounter 
                }
            }
        })

    241. Connecting Redux Toolkit State
        Como conectamos nuestro slice al store y enviamos acciones?

        // nos guardamos el valor de retorno de createSlice

        const counterSlice = createSlice({
            name: 'counter',
            initialState: initialState,
            reducer: {
                increment(state) {
                    state.counter++ 
                },
                decrement(state) {
                    state.counter--
                },
                increase(state, action) {
                    state.counter = state.counter + action.amount
                },
                toggleCounter(state) {
                    state.showCounter = !state.showCounter 
                }
            }
        })

        // eliminamos nuestro counterReducer y para no atarnos a un solo store, importamos y utilizamos otro Hook
        import { createSlice, configStore } from '@reduxjs/toolkit'

        configStore, hace lo mismo que createStore, solamente que mergea los reducers en uno

        // configuramos nuestro store, reducer en singular ojo. ya que solo necesitamos UN REDUCER
        // para que después podamos usar mas de un reducer, debemos usar un objeto, y pasarle un nombre y el slice correspondiente.
        // si tenes un solo reducer, no necesitas crear el objeto, o sea, el lo deja sin, porque el ejemplo es basico.

        const store = configureStore({
            reducer: {
                counter: counterSlice.reducer
            }
        })
        
    242. Migrating Everything To Redux Toolkit
        Detras de escena, redux crea identificadores para cada acción que configuramos.

        para usar las acciones, debemos exportarlas:

        export const counterSlice.actions

        en donde dispatcheabamos las cosas, ahora exportamos las acciones y la distpacheamos de manera difeente:
            dispatch(counterActions.increment())

        cuando tienen payload:
        le podemos pasar un objeto con las propiedades y el valor o directamente el valor.
            dispatch(counterActions.increase(10))

        Para extraer ese valor el tema es que hay que usarlo de otra manera, en la función que se usa el valor hay que hacer:
        En nuestro caso cambiar el valor de la prop, por el payload que tiene el valor, si fuera prop, payload.laprop

        increase(state, action) {
            state.counter = state.counter + action.payload
        }

    243. Working with Multiple Slices
        abajo del otro slice, igual no importa el orden, creamos otro slice para la parte de autenticación.

        bueno ahora si usa reducer y un objeto para poner ambos pedazos de store y exporta la nueva acción

    244. Reading & Dispatching From A New Slice
        En App, usa la nueva acción para renderizar de manera condicional el login o el profile del usuario.

    245. Splitting Our Code
        cada slice, o sea, pedacito de store, lo pasa a su propio js.

        counter.js, auth.js

    246. Summary

    247. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/18-diving-into-redux

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 19: Advanced Redux

    248. Module Introduction
        ...

    249. Redux & Side Effects (and Asynchronous Code)
        Los reducers tienen que ser puros, sin side effects, con funciones sincronicas.
        input (old state +  action) -> output (new state)

        donde ponemos nuestros side effects y async task?
        dentro de componentes useEffect, dentro de creadores de acciones.

    250. Refresher / Practice: Part 1/2
        Va avanzando metiendo redux en el proyecto que dejó en la 249..

    251. Refresher / Practice: Part 2/2
        Continua avanzando metiendo redux en el proyecto que dejó en la 249..

    252. Redux & Async Code
        Las llamadas se hacen dentro de useEffect en los componentes o dentro de los action creators.
        ...

    253. Frontend Code vs Backend Code
        Va a usar Firebase, por ende hay que hace run poco mas de laburito de front, si fuera una api que llama a una bd, sería otra cosa.

    254. Where To Put Our Logic
        https://github.com/academind/react-complete-guide-code/tree/19-advanced-redux/code/zz-suboptimal-example-code
        Para código sincronico, y código que no tiene side effects, por ej, transformación de data:
            El prefiere reducers para hacer llamados Http, evitando componentes y actions creators.
        
        Para async code, con side effects:
            Prefiere actions creators o componentes, NUNCA USAR REDUCERS.-

    255. Using useEffect with Redux
        usa useEffect en App, aunque podría haber sido en otro componente, ahí hace el fetch a firebase para actualizar info del carrito.
        Lo que hace con esto, al estar usando redux, es que si se actualiza el estado del carrito, useEffect se vuelev a ejecutar y a pushear un producto al carrito, sin mucho kilombo, 
        mantiene la logica de agregar items al carrito dentro del reducer en el store/slice-cardt y listo.-
        
    256. A Problem with useEffect()
        We face one problem when using useEffect the way we currently do it: It will execute when our app starts.
        Why is this an issue?
        It's a problem because this will send the initial (i.e. empty) cart to our backend and overwrite any data stored there.
        We'll fix this over the next lectures, I just wanted to point it out here!

    257. Handling Http States & Feedback with Redux
        Arregla el temita de que useEffect se ejecuta la primera vez cuando arranca la app metiendo un producto vacio al carrito.
        https://github.com/academind/react-complete-guide-code/tree/19-advanced-redux/extra-files

    258. Using an Action Creator Thunk
        Otra manera de ejecutar side-effects y tareas asincronicas es dentro de las actions creators.

        Thunk, es una función que retrasa una acción hasta mas tarde, hasta que algo termine.
        
        Podríamos crear una acción como un thunk, para escribir un action creator, que no retorne inmediatamente la acción del objeto, pero 
        a la vez retorna otra función que evetualment retorna una acción.

        Para crear nuestro propio action creator, creamos una función:
        Que retorne OTRA FUNCIÓN.

        const sendCartData = (cartData) => {
            return (distpach) => {
                // antes de dispatchear podemos hacer la llamada asincronica.
                dispach(
                    uiActions.shownotification({
                        status: 'pending',
                        title: 'Sending...',
                        message: 'Sending cart data!'
                    })
                )

                const response = await fetch(
                    'url',
                    {
                        method: 'PUT',
                        body: JSON.stringify(data)
                    }
                })

                if(!response.ok){
                    ...
                }

                 dispach(
                    uiActions.shownotification({
                        status: 'success',
                        title: 'Sending...',
                        message: 'Sent cart successfully!'
                    })
                )
            }
        }

        redux acepta actions creators que retornan functions, esta preparado para eso.-

    259. Getting Started with Fetching Data
        pone el fetch en otro lado del código..

    260. Finalizing the Fetching Logic
        continua...
        
    261. Exploring the Redux DevTools
        Instala la extensión de Chrome y muestra como va cambiando el estado en la consola del desarrollador

    262. Summary
        Resumen...

    263. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/19-advanced-redux

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 20: Building a Multi-Page SPA with React Router

    264. Module Introduction
        ...

    265. What is Routing & Why?
        El enrutamiento se trata de poder mostrar diferentes paginas a el usuario.

        Router Package:
        Parsear url / path -> configurar las rutas ->  renderiza / carga el jsx apropiado / componente

    266. Installing React Router
        npm install --save react-router react-router-dom

    267. Defining & Using Routes
        importamos BrowserRouter y envolvemos el div de app por ej, a partir de ahí en todos los subcomponentes se van a poder acceder a las funcionalidades de este componente. 
        (La funcionalidad sería parecida a la de Context)

        App.js
            import { Route } from 'react-router-dom';

            <Route path="/welcome">
                <Welcome />
            </Route>

        index.js
            import { BrowserRouter } from 'react-router-dom'
            <BrowserRouter>
                <App />
            </BrowserRouter>

        Mete las diferentes paginas en src/pages

    268. Working with Links
        Comenta que no es correcto usar Route, sino que hay que importar y usar Link

            Para eso modifica en en el nav, los <a> por el componente link
            React router genera la etiqueta de anclaje y previene el reload, por lo tanto
            to, apate de ser un string, también se le puede pasar una función, un objeto...

            hash -> esto sirve para si hay algún id con submit, directamente vaya a esa pagina.
            search -> nos habilita a pasar parametros por query

            <Link to="/"> Home</Link>

            Son ejemplos para que sepamos que existen, pero no lo vamos a usar así.
            <Link to={{
                pathname: '/new-post',
                hash: '#submit',
                search: '?quick-submit=true',
            }}> New Post</Link>

            Si hacemos click ahora vamos a ver que no se actualiza la pagina entera (se nota en el icono de reload del navegador, que no se mueve esta vez-)

    269. Using NavLinks
        https://github.com/academind/react-complete-guide-code/blob/20-building-mpas-with-react-router/extra-files/index.css
        https://github.com/academind/react-complete-guide-code/blob/20-building-mpas-with-react-router/extra-files/MainHeader.module.css

        Cuando cambiamos de ruta, si estamos usando <NavLink> para estilar. Dice que como es un caso raro, no pasa nada (?)

        <NavLink
            activeClassName="my-active"
            actuveStyle={{
                color: #6546
                textDecoration: underline
            }}
        >
        de react-router-dom se usa para estilar los links, magicamente te deja estilar los links tiene otras propiedades también, pero bueno la magia de estilar el link que esta activo se maneja con este componente.

        Con actuveStyle se aplican estilos en linea.
            
    270. Adding Dynamic Routes with Params
        <Link to="/my-path/:productId">Go to Start</Link>

    271. Extracting Route Params

        Ahora si hacemos props.match.params.id vamos a tener el idque pasamos y seteamos en nuestro <Route>
        You learned how to extract route parameters (=> :id  etc).

        But how do you extract search (also referred to as "query") parameters (=> ?something=somevalue  at the end of the URL)? How do you extract the fragment (=> #something  at the end of the URL)?

        Query Params:
        You can pass them easily like this:

        <Link to="/my-path?start=5">Go to Start</Link>

        or

        <Link
            to={‌{
                pathname: '/my-path',
                search: '?start=5'
            }}
            >Go to Start</Link>

        React router makes it easy to get access to the search string: props.location.search .

        But that will only give you something like ?start=5

        You probably want to get the key-value pair, without the ?  and the = . Here's a snippet which allows you to easily extract that information:

        componentDidMount() {
            const query = new URLSearchParams(this.props.location.search);
            for (let param of query.entries()) {
                console.log(param); // yields ['start', '5']
            }
        }
        URLSearchParams  is a built-in object, shipping with vanilla JavaScript. It returns an object, which exposes the entries()  method. entries()  returns an Iterator - basically a construct which can be used in a for...of...  loop (as shown above).

        When looping through query.entries() , you get arrays where the first element is the key name (e.g. start ) and the second element is the assigned value (e.g. 5 ).

        Fragment:
        You can pass it easily like this:

        <Link to="/my-path#start-position">Go to Start</Link>

        or

        <Link
            to={‌{
                pathname: '/my-path',
                hash: 'start-position'
            }}
            >Go to Start</Link>
        React router makes it easy to extract the fragment. You can simply access props.location.hash .

    272. Using "Switch" and "exact" For Configuring Routes
        Switch basicamente lo que hace es: cargar la primer ruta que realmente coincida y deja de analizar el resto.

        El orden es importante, tampoco es necesario meter todo dentro del switch, 
        hay que ver que hacer depende de lo que necesitemos.

        <Route path='/products' exact>
        <Route path='/products/:prodId' >

    273. Working with Nested Routes
        Podes utilizar <Route> en cualquier parte de tu aplicación, siempre y cuando el enutador atrape el componente que lo esta utilizando.
        Para que sea realmente dinamico, en vez de hardcodear /post/id, vamos a usar props.match.url, que es la ruta que llamó a ese componente y después se le suma '/:id', por lo tanto va a matchera con la ruta.
        después sigue sin funcionar porque tiene chequeo estricto, así que o convertimos a number o le sacamos el stricto y listo.
        Otra manera de convertir algo a number es meterle un + adelante.

    274. Redirecting The User
        Una solución diferente a poner una ruta abajo de la otra es, en el switch utilizar
            <Redirect from="/" to="/welcome" />

            De esta manera hacemos que el usuario vaya a donde realmente debería estar.

            Conditional Redirects
                Lo que hace es generar por ejemplo un Redirect, solo si el formulario se submitió, entonces renderiza nu componente <Redirect> condicionalmente.

                <Redirect to="/welcome">

                No es necesario que le digamos desde donde from=

            Using the History Prop to Redirect (Replace)
                Cambiamos el redirect por push con history.
                Push, lo que hace es enviar la pagina a la pila, por ende podemos volver atrás.
                no así con redirect.

                Redirect reemplaza el lugar donde estabamos, por eso no podemos volver atras.

                También existe props.history.replace, que hace lo mismo que redirigir.

    275. Time to Practice: Onwards to a New Project
        ...

    276. Practice Redirecting & Extracting Params
        ...

    277. Practicing Nested Routes
        ...

    278. Adding a Layout Wrapper Component
        Crea un componente Layout que espera un children y basicamente lo llama en app donde estan todos los switchs de las rutas.

    279. Adding Dummy Data & More Content
        ...

    280. Outputting Data on the "Details" Page
        ...

    281. Adding a "Not Found" Page
        <Route path='*'>
            <NotFound>
        </Route>

    282. Implementing Programmatic (Imperative) Navigation
        Va a mostrar una alternativa a usar link envolviendo en este caso <Post>

        También podemos usar history y pushear la nueva ruta al historial.

        props.history.push({pathname: "/" + props.match.params.id});

    283. Preventing Possibly Unwanted Route Transitions with the "Prompt" Component
        Si, sin querer te vas hacía atras, perdes todo lo que llenaste en el formulario, entonces la idea es poner un 
        dialog que te pregunte si queres perder los camibios que venías haciendo.

        import { Prompt } from 'react-router-dom'

        En el form, usa onFocus


        <Prompt when={isEntering} message={(location) => 'Estas seguro de salir'} > 
        muestra un prompt como el alert, horrible.

    284. Working with Query Parameters
        https://github.com/academind/react-complete-guide-code/blob/20-building-mpas-with-react-router/extra-files/sorting.js

        Hace un filtro, y juega con el cambio de estado del location y los queries parameters, entonces si en el filtro
        vos cambias el tipo de filtro, la pagina se refresca y no va a otra porque sigue en la misma ruta, solo cambia
        uno de los parametros 

        <Link to="/my-path?start=5">Go to Start</Link>

    285. Getting Creative With Nested Routes
        cualquier cosa verlo, hace como un loading, sin un loading, para que aparezcan los comentarios. zzz

    286. Writing More Flexible Routing Code
        const match = useRouteMatch();
        const params = useParams();
        const location = useLocation();

        tiene toda la info con de la location, sirve para no andar escribiendo las rutas a mano sino que las tomamos de ahí.
        idem con params, lo sacamos con ese hook en vez de andar haciendo location.match.params

    287. Sending & Getting Quote Data via Http
        con los hooks que hizo el antes use http y una libreria que hace de api, obtiene las quotes del proyecto contra firebase.

    288. Adding the "Comments" Features
        ver de ser necesario, agrega ese feature a lo que venía haciendo..

    289. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).
        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/20-building-mpas-with-react-router
        Usage instructions can be found on the page that link is leading to.
        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.
        You also find section slides (if available) in that Github repository.

# Section 21: Deploying React Apps

    290. Module Introduction
        ...

    291. Deployment Steps
        Escribir código
        Testearlo
        Optimizarlo
        buildear 
            -> npm run build
        subir el código a un server
        Configurar server o hosting.

            el servidor siempre tiene que servir el index.html (sino da 404)
                ->  actualizar el artefacto a static del build
                ->  githubpages o firebase se puede implementar porque es todo estatico, no hace falta un servidor, tendría que haber una carpeta /build

    292. Adding Lazy Loading
        https://www.udemy.com/join/login-popup/?next=/course/react-the-complete-guide-incl-redux/learn/lecture/25599594#overview

        divide el código para que se descarguen solo los js cuando realmente sea necesario, o sea, cuando se llama
        especificamente a una ruta.
        Por ej todo lo que tenemos en app importados en App por cada ruta que vamos a querer rutear.

        import React, { Suspense } from 'react'

        // solo queremos descargar NewQuote cuando el usuario realmente visite /NewQuote
        // Esto cre un nuevo js chunk, solo cuando pasa eso, esto tarda unos milisegundos, para eso se define
        un fallback, y para eso usamos Suspense.

        const NewQuote = React.lazy(() => import('./pages/NewQuotes'))
        Debajo de Layout, tenemos que usar suspense,

        <Suspense fallback={<div className='centered'> <LoadingSpinner /> </div>}
        
        Así podemos hacer con cada page a importar.

        Todo esto hace que el bundle que se genera se mucho mas chico y por ende la pagina levante mas rapido.

    293. Building The Code For Production
        corre el comando npm run build
        muestra la carpeta build que se creo con todo minimizado...

    294. Getting Started With Deployment (Uploading Files)
        googlea: static hosting providers, usa firebase.

        En la consola de firebase > setup hosting > npm install -g firebase-tools > continue > firebase login > firebase init > firebase deploy
            hosting hay que elegir en login, después la carpeta build, si, es una SPA, no a sobreescribir el index y listo
            te genara un link tipo firebase.burgerApp.com bla entras y listo.

            parecido a heroku.

    295. Exploring Routing Issues & Finishing Deployment

    296. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).
        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/21-deploying-react-apps
        Usage instructions can be found on the page that link is leading to.
        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.
        You also find section slides (if available) in that Github repository.

# Section 22: Adding Authentication To React Apps

    297. Module Introduction
        ...

    298. What, How & Why?
        Se necesita para contenido que debe estar protegido, no accesible para todos.
        Obtengo acceso logueandome, 
        Envio un request a un recurso protegido.

        Server-Side sessions
            Store unique identifier on server, send same identifier to client.
            client sends identifier along with requests to protected Resources
        
        Authentication Tokens
            Create (but not store) "permission" token on server, send token to client

    299. More on "Authentication Tokens"
        When working with "Authentication Tokens", these tokens are typically created in the "JSON Web Token" Format (JWT).

        As explained in the previous lecture, those "tokens" are really just long strings which are constructed by an algorithm that encodes data into a string (with help of a private key, only known by the server).

        You can learn more about JSON Web Tokens (JWTs) here: https://jwt.io/

    300. Starting Setup & First Steps
         Explica que va a usar firebase como dummy backend
        Firebase Auth Rest api
        
    301. Adding User Signup
        SPA -> envia un auth al SERVER, el server no devuelve una sesión sino un TOKEN (json), generalmente se guarda en el localStorage, no se puede guardar en el estado porque si refresca la pagina se pierde..
        
        Para hacer ciertos request necesitamos estar autenticados, entonces para no andar validando eso todo el tiempo en el request se envia el token con cierta información

        Si bien acá usamos Firebase, el token se puede generar en cualuqier server.

        En firebase va a la sección de autenticación, elije como sing-in provider EMAIL/PASSWORD.
        
            Enable > save.

            Busca en Firebase el api key, para pegarle al nuevo endpoint.
            Autenticación > web setup

            Elige la url de sing up, la pone dentro del archivo auth, que esta dentro de la carpeta store > actions > auth.js en la parte donde se exporta la función auth, ahí hace el post.

            Verifica que datos tiene que mandarle en el body al endpoint, lo prueba y muestra por consola que le retorno bien la info.

    302. Showing Feedback To The User
        Muestra por ahora con alerts, las respuestas de error o login ok.

    303. Adding User Login
        Muestra como cuando se loguea firebase le devuelve todo un response con un payload especifico.

    304. Managing The Auth State With Context
        Acá usa context para no instalar redux, pero se podría manejar ahí tranquilamente.

    305. Using The Token For Requests To Protected Resources
        Muestra como enviar el token para cuando usa el endpoint de cambio de contraseña.

    306. Redirecting The User
        Muestra como redireccionar una vez que esta bien logueado.

    307. Adding Logout
        Solo setea el token guardado en el context, en null.

    308. Protecting Frontend Pages
        "Guards" 
        Basicamente sirve para utilizar en esas rutas que sabes que el usuario necesita estar autenticado.
        Algo asi como el [Authorized] pero autenticado.

        te fijas si el usuario esta logueado y sino no renderizas el componente. Esto no evita que si esta logueado, se pueda meter a otras secciones que no tiene permiso por el perfil.

    309. Persisting The User Authentication Status
        https://academind.com/tutorials/localstorage-vs-cookies-xss/

        muestra como guarda el token en el localStorage

    310. Adding Auto-Logout
        muestra como le mete un tiempo de expiración al token y como limpia el token en el localStorage
        
    311. Finishing Steps
        Mejora el timer, para el auto-logout

    312. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).
        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/22-authentication
        Usage instructions can be found on the page that link is leading to.
        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.
        You also find section slides (if available) in that Github repository.

# Section 23: A (Pretty Deep Dive) Introduction to Next.js

    313. Module Introduction
        ...

    314. What is NextJS?
        the react framework for production (la dif con una libreria es que tiene muchos mas features)
        esta basado por encima de react, te hace la vida mas facil, agregando features que con react tenes que instalar 
        extra

    315. Key Feature 1: Built-in Server-side Rendering (Improved SEO!)

        Es una libreria basada en react, fuerza una estructura especifica y nos da server side rendering y configuración extra que no tenemos que hacer a mano.
        Server side rendering ayuda mucho a los search engine

        Server Side Rendering simplemente significa, cuando un usuario entre a una url, se va a estar pre-renderizando esa pagina, del lado del servidor y lo va a retornar ya "cocinado"
        O sea, el cliente hace un request al server, el server hace el fetch y renderiza la app, retorna renderizada la primer pagina + react app bundle y en el cliente se re-renderiza la SPA.

        Excelente para SEO.


        1) Server-side Rendering
            Automaticamente se pre renderiza la pagina, excelente para SEO.
            Fetch data en el servidor, rendereado de paginas "finalizadas"

    316. Key Feature 2: Simplified Routing with File-based Routing
        
        2) File-based Routing
            No se usa react-router, next.js se basa en file-base routing
            Basicamente lo que se usa es carpetas y archivos para ir ruteando nuestra url, next js parsea esto y usa su propio ruteador interno, 
            pre renderiza y automaticamente splitea y con lazy load lo muestra.

            con pages/ ruteamos 
         
    317. Key Feature 3: Build Fullstack Apps

        3) Fullstack capabilities
            Se agrega facilmente un backend server-side a tu app next/react
            podes guardar data, obtener, auth, etc. se puede agregar a tus proyectos de react.

    318. Creating a New Next.js Project & App

        1) npx create-next-app > y > ponerle un nombre

    319. Analyzing the Created Project
        pages -> donde van a estar cada pagina
        styles -> donde van a estar los estilos..
        public -> donde va a estar las imagenes e index

    320. Adding First Pages
        Eliminar la carpeta api, los css que vienen...

        pages/
            index.js // nuestra pag principal.

                // no es necesario importar React, en las ultimas versiones.

                const indexPage = () => {
                    <div>
                        <h1> Main Page </h1>
                    </div>
                };

                si inspeccionas la pagina, esta el html de la pgina renderizada, porque viene del server, no así en react.

    321. Adding Nested Paths & Pages (Nested Routes)
        pages/
            news/
                index.js -> la principal de index, midominio.com/news
                algo.js -> la nesteada, o sea midominio.com/news/algo

    322. Creating Dynamic Pages (with Parameters)
        para crear una pgina dinamica:
        
        ej:
            [newsId].js

    323. Extracting Dynamic Parameter Values
        Para extraer el valor se usa un hook,

        import { useRouter} from 'next/router';

        const Componente = () => {
            const router = useRouter()
            console.log(router.query.newsId) // lo que se pase como parametro ej news/pedo va a ser pedo.
        }

    324. Linking Between Pages
        muestra como construye un link con html regular
            significa que no tengo una SPA cuando hago click porque se refresca la pagina buscando el nuevo recurso.

        muestra como construye un link con next.js
            con este feature vemos que no se refresca mas 

            import Link from 'next/link';

            <Link href="/news/algo">
                Algo
            </Link>

    325. Onwards to a bigger Project!
        habla del proyecto, y deja el zip

    326. Preparing the Project Pages
        también se pueden crear rutas dinamicas, nesteando carpetas, ej
        pages/[meetupid]/index.js
        
    327. Outputting a List of Meetups
        se baja una imagen de wikipedia..
        
    328. Adding the New Meetup Form

    329. The "_app.js" File & Layout Wrapper

    330. Using Programmatic (Imperative) Navigation

    331. Adding Custom Components & CSS Modules

    332. How Pre-rendering Works & Which Problem We Face

    333. Data Fetching for Static Pages

    334. More on Static Site Generation (SSG)

    335. Exploring Server-side Rendering (SSR) with "getServerSideProps"

    336. Working with Params for SSG Data

    337. Preparing Paths with "getStaticPaths" & Working With Fallback Pages

    338. Introducing API Routes

    339. Working with MongoDB

    340. Sending Http Requests To Our API Routes

    341. Getting Data From The Database

    342. Getting Meetup Details Data & Preparing Pages

    343. Adding "head" Metadata

    344. Deploying Next.js Projects

    345. Using Fallback Pages & Re-deploying

    346. Summary
        ...

    347. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).
        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/23-nextjs-introduction
        Usage instructions can be found on the page that link is leading to.
        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.
        You also find section slides (if available) in that Github repository.

    TODO: Sección 23: Bonus: Next.js
      
        390. Styling our App in Next.js

            Next JS tiene su propia manera de estilar. Podemos usar Radium, podes usar estilos en linea, no podemos usar CSS Modules.

            Styled-jsx

            <style jsx> {`
                div {
                    border: 1px solid black;
                }
            `} </style>

        391. Handling (404) Errors
            Next js tiene una pagina por default para esto, si se quiere sobreescribir hay que generar un archivo _error.js dentro de pages.

        392. A Special Lifecycle Hook

            Transforma el componente funcional en un componente de clase.

            usa una función nueva que también esta en functional components.

            Static puede ser llamado sin ser instanciado y es asincrono, retorna algo instantaneamente.
                Se puede usar async o no. *
            Sirve para inicializar tu app antes de que se cargue.
                Podríamos traer info de la bd x ej.

            static async getInitialProps(context){
                // console.log(context);
                const promise = new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve({appName: 'Super App});
                    }, 1000);
                });
                return promise;
            }

            Después lo usamos en el retorno de jsx.
                <h1> this.props.appName </h1>

            Solo va a renderizar esa parte, cuando se retorne la promesa.

            * Hace el ejemplo también con functional components.

        393. Deploying our App

            npm run build   -> para buildear el proyecto para deployarlo.

# Section 24: Animating React Apps

    348. Module Introduction

    349. Preparing the Demo Project

    350. Using CSS Transitions

    351. Using CSS Animations

    352. CSS Transition & Animations Limitations

    353. Using ReactTransitionGroup

    354. Using the Transition Component

    355. Wrapping the Transition Component

    356. Animation Timings

    357. Transition Events

    358. The CSSTransition Component

    359. Customizing CSS Classnames

    360. Animating Lists

    361. Alternative Animation Packages

    362. Wrap Up

    363. Module Resources

# Section 25: Replacing Redux with React Hooks

    364. Module Introduction

    365. Starting Project & Why You Would Replace Redux

    366. Alternative: Using the Context API

    367. Toggling Favorites with the Context API

    368. Context API Summary (and why NOT to use it instead of Redux)

    369. Getting Started with a Custom Hook as a Store

    370. Finishing the Store Hook

    371. Creating a Concrete Store

    372. Using the Custom Store

    373. Custom Hook Store Summary

    374. Optimizing the Custom Hook Store

    375. Bonus: Managing Multiple State Slices with the Custom Store Hook

    376. Wrap Up

    377. Module Resources

# Section 26: Testing React Apps (Unit Tests)

    378. Module Introduction

    379. What & Why?

    380. Understanding Different Kinds Of Tests

    381. What To Test & How To Test

    382. Understanding the Technical Setup & Involved Tools

    383. Running a First Test

    384. Writing Our First Test

    385. Grouping Tests Together With Test Suites

    386. Testing User Interaction & State

    387. Testing Connected Components

    388. Testing Asynchronous Code

    389. Working With Mocks

    390. Summary & Further Resources

    391. Module Resources

# Section 27: React + TypeScript

    392. Module Introduction

    393. What & Why?

    394. Installing & Using TypeScript

    395. Exploring the Base Types

    396. Working with Array & Object Types

    397. Understanding Type Inference

    398. Using Union Types

    399. Understanding Type Aliases

    400. Functions & Function Types

    401. Diving Into Generics

    402. A Closer Look At Generics

    403. Creating a React + TypeScript Project

    404. Working with Components & TypeScript

    405. Working with Props & TypeScript

    406. Adding a Data Model

    407. Time to Practice: Exercise Time!

    408. Form Submissions In TypeScript Projects

    409. Working with refs & useRef

    410. Working with "Function Props"

    411. Managing State & TypeScript

    412. Adding Styling

    413. Time to Practice: Removing a Todo

    414. The Context API & TypeScript

    415. Summary

    416. Bonus: Exploring tsconfig.json

    417. Module Resources

# Section 28: Optional: React Hooks Introduction & Summary|

    418. Module Introduction

    419. What Are React Hooks?

    420. The Starting Project

    421. Getting Started with useState()

    422. More on useState() & State Updating

    423. Array Destructuring

    424. Multiple States

    425. Rules of Hooks

    426. Passing State Data Across Components

    Assignment 6: Time to Practice: Hooks Basics

    427. Sending Http Requests

    428. useEffect() & Loading Data

    429. Understanding useEffect() Dependencies

    430. More on useEffect()

    431. What's useCallback()?

    432. Working with Refs & useRef()

    433. Cleaning Up with useEffect()

    434. Deleting Ingredients

    435. Loading Errors & State Batching

    436. More on State Batching & State Updates

    437. Understanding useReducer()

    438. Using useReducer() for the Http State

    439. Working with useContext()

    440. Performance Optimizations with useMemo()

    441. Getting Started with Custom Hooks

    442. Sharing Data Between Custom Hooks & Components

    443. Using the Custom Hook

    444. Wrap Up

    445. Module Resources

# Section 29: Optional: React Summary & Core Feature Walkthrough

    446. Module Introduction

    447. What Is React?

    448. Why React?

    449. Building SPAs (Single Page Applications)

    450. React Alternatives

    451. Creating a React Project

    452. Setting Up A Code Editor

    453. Diving Into The Created Project

    454. How React Works & Understanding Components

    455. More Component Work & Styling with CSS Classes

    456. Building & Re-Using Another Component

    457. Working with "props" & Dynamic Content

    458. Handling Events

    459. Adding More Components

    460. Introducing State

    461. Working with "Event Props" (Passing Function As Props)

    462. Adding Routing

    463. Adding Links & Navigation

    464. Styling with CSS Modules

    465. Outputting Lists of Data

    466. Adding More React Components

    467. Building Wrapper Components with props.children

    468. Adding a Form

    469. Getting User Input & Handling Form Submission

    470. Preparing the App for Http

    471. Sending a POST Request

    472. Navigating Programmatically

    473. Getting Started with Fetching Data

    474. Using the useEffect() Hook

    475. Introducing React Context

    476. Context Logic & Different Ways Of Updating State

    477. Using Context In Components

    478. More Context Usage

    479. Summary

    480. Module Resources

# Sección 30: Course Roundup

    481. What Now? Next Steps You Could Take!
        ...

    482. Explore The React Ecosystem!
        Gatsby
        PREACT
        React Native
        
    483. Finishing Thoughts
        ...

    484. Bonus!

        With this course, you learned a lot about React!

        But the React ecosystem is huge and there are tons of things you can do and build with React, for example:

        Learn how to build server-side rendered (great for SEO!) or fullstack apps with Next.js & React: https://acad.link/nextjs

        Build mobile Android & iOS apps with React Native: https://acad.link/react-native

        Build fullstack MERN (MongoDB, ExpressJS, React, NodeJS) web apps: https://acad.link/mern

        Or dive into one of the many other courses I have on web development, JavaScript etc: https://academind.com/courses/

# Section 31: This Course Got Updated!

    485. Course Update Overview, Explanation & Migration Guide
        
        Porque React evoluciono y ahora el standar es functional component + react hooks...
        Porque el loco creció y con el feedback mejoró el curso y como explicaba.....

    486. Course Update & Migration Guide
        ***

        PLEASE READ THIS ENTIRE DOCUMENT CAREFULLY

        It contains detailed information on WHY the course is updated, WHAT changed and what that means for you and your course progress!

        FAQs (e.g. "How do I regain my course progress" can be found at the end of this document!)

        ***

        On April 12th 2021, I updated this entire course to make it future-proof and teach the latest version of React in the best-possible way.

        For that, I completely re-recorded this course - you get this brand-new course for free!

        In a nutshell, this means that this course switched from "class-based components for state management" to "using React Hooks with functional components right from the start".

        What you learned with the old course is not obsolete - I simply updated the course to make it future-proof and embrace modern React practices (specifically function components + hooks) right from the start!

        I re-recorded the entire course (i.e. I created a brand-new course), incorporating all the latest best practices and all the amazing feedback I got from you over the years.

        Here's what you need to know about this update (and what it means for you) - please read this article carefully!

        I completely re-recorded the course and therefore created a brand-new 40h+ course!

        You get this update 100% for free and you don't need to do anything for that!

        The new course is inserted into this existing course (in front of the old course) - i.e. lecture 1 in section 1 is the new course after April 12th

        The old course content will stay around for a short transitional period (planned to end on May 3rd) after which it will be removed

        You keep access to the old course though: Download links (to videos, VTT caption files and course attachments) are provided in the next lecture

        Details on how you should proceed (based on your current course progress) can be found below!

        Why did I update the course?
        Over the years and months, React evolved and today, you write React code slightly different than you did in the past. Most importantly, we nowadays use functional components + React Hooks instead of using class-based components for state management.

        Whilst I do cover React Hooks in-depth in this course, the course still starts with a strong focus on class-based components (just like the official docs still do by the way). That is not bad or incorrect but it doesn't reflect the future of React. And hence, to make this course future-proof and teach you React in the most modern way possible, I updated the course to fully embrace functional components + React Hooks.

        What changed?
        I also used the opportunity to improve the content in general and add some new content (besides the general restructuring due to the switch to "React Hooks first"):

        The single, large course project (the burger builder) will be replaced by multiple smaller, more focused (yet realistic) demo projects so that skipping modules or coming back to modules will be easier (and so that you got more variety!)

        A brand-new, in-depth introduction to Next.js (> 3h!) was added to the course

        A React summary module was added: You can use that after going through the course or as a "mini course" that teaches you the essence of React => Great if you have limited time and don't want to go through the full course right now

        Overall, explanations and examples were improved, as I had to create a brand-new course anyways (due to the switch to "React Hooks first")

        More new content (on React + TypeScript, Authentication, Testing) will be added after May 3rd (once the old lectures were removed) - I can't add that content yet since there is a "maximum number of lectures" limitation on Udemy

        What about the old course?
        As mentioned, the old content stays around for a short transitional period until May 3rd - thereafter it will be removed. You will keep access to it thereafter via download links though (see next lecture).

        Because Udemy has a lecture limit (max amount of published lectures), I also had to remove some less important old content right away: The Webpack section, the old, short Next.js section, the old Deployment section, the Redux Saga section.

        All those sections are of course still available via download!

        How should you proceed?
        How you should proceed depends on your current status:

        You haven't started the course yet or you haven't progressed much yet ("NOT STARTED")

        You are well into the course already and you're currently doing the course ("WELL INTO THE COURSE")

        You completed the course in the past or you haven't visited it for a longer time period ("COMPLETED / PAUSED")

        NOT STARTED

        Simply restart with the updated course (i.e. take lecture 1 in section 1 to start the new course)

        Ignore the old course content, the new course will teach you everything in a better way

        WELL INTO THE COURSE

        Consider restarting if you have the time: The new course will contain sharpened explanations, new demos and examples and is arguably a bit better than the old one

        But you can also just finish the existing course (in the transitional period until May 3rd or by downloading the old course content, see next lecture)

        You will still learn React in a best-practice way! You will learn all about React Hooks => It's just the strong focus on class-based components which is not as important anymore

        Definitely explore the recommended new content you find below!

        COMPLETED / PAUSED

        You can ignore the update in general as you did still learn React in a best-practice way! You did learn all about React Hooks => It's just the strong focus on class-based components which is not as important anymore

        If you have the time, definitely consider taking the full course again: It will contain sharpened explanations, new demos and examples and simply is better than the old one!

        Definitely explore the recommended new content you find below!

        New Content Which You Definitely Should Explore
        The new first ("Getting Started") module to get an overview of the new course

        The Next.js introduction module

        The React.js summary module

        The new Routing ("Building a Multi-Page SPA with React Router") module

        The new Redux sections => They now also include Redux Toolkit!

        The new Testing section (released on May 3rd)

        The new Authentication section (released on May 3rd)

        The new React + TypeScript section (released on May 3rd)

        All the new "Project" or "Practice" course sections where we build demo apps

        Frequently asked questions
        What about my course progress / course completion certificate?

        Unfortunately, since the new course was inserted into this existing course, your course progress is reset / diluted.

        But you get a complete new course with many improvements for free! It's probably worth it ;-)

        To regain your course progress and certificate, you can simply mark lectures as completed manually. It's annoying but will only take a few minutes.

        What about my notes or existing threads in the Q&A section (for the old content)?

        Unfortunately, notes and existing Q&A threads will be lost, once the old content is removed (i.e. lectures are unpublished). Udemy doesn't offer a way of saving that data at the moment - that is beyond my control.

        Why didn't you create a new course?

        I wanted to make this update available for free!

        There also is no possible way on Udemy to offer a brand-new course for free (without leaking it to the entire world) anymore, hence this is the best approach going forward. It also ensures that no student misses this update!

        Will you remove the old content?

        Yes, please see above.

        Why will you remove the old content?

        Because it unnecessarily bloats the course, makes it look bigger than it is and forces students to go through two courses instead of one. Keeping it around therefore is only a temporary workaround.

        I have another question!

        If it wasn't answered in this article already, feel free to ask in the Q&A - I'll do my best to help there! :)

        Resources for this lecture
        course-update-udemy.pdf

    487. Old Course Content Download

        Attached to this lecture you find download links to the old course content (by sections).

        Each ZIP file contains the videos, VTT captions and code attachments for the section.

        You should ignore that old course content if you took / are taking the updated course - the new course is more detailed and simply better.

        Unfortunately, Udemy messed up the attachment order (and I can't change that order), so don't get confused by that :)

        Resources for this lecture
        01 Getting Started.zip
        02 JS Refresher.zip
        02 Base Syntax.zip
        05 Styling.zip
        06 Debugging.zip
        07 Component Deep Dive.zip
        10 Http Project.zip
        09 Http.zip
        08 Project Burger Builder Start part 1.zip
        08 Project Burger Builder Start part 2.zip
        12 Routing Project.zip
        14 Redux Basics.zip
        11 Routing.zip
        13 Forms.zip
        15 Redux Project.zip
        04 Lists & Conditionals.zip
        zz Bonus Next.js.zip
        zz Bonus Redux Saga.zip
        zz React Hooks part 2.zip
        zz React Hooks Burger Builder.zip
        zz Bonus Burger Builder CSS.zip
        20 Testing.zip
        17 Advanced Redux Project.zip
        zz Bonus Animations.zip
        zz Bonus Webpack.zip
        19 Burger Improvements.zip
        zz React Hooks part 1.zip
        22 Roundup.zip
        18 Authentication.zip
        16 Advanced Redux.zip
        21 Deployment.zip

# ----------------------------------- SECCIONES VIEJAS --------------------------------------    

    # Sección 6, cosas que quedaron por revisar:
        71. More on Styled Components
                Como funcionan realmente?

                Si nos fijamos en el html, los nombres de las clases que se generaron son fruta, estos nombres los genera el framework.

                El package agarra todo el css y lo pone como selectores de clase y los agrega al encabezado documento, y después agrega el css al div que es retornado por ese compoenente.

            73. Working with CSS Modules
                npm run eject
                // Esto ya se hace varias veces en el curso, buscarlo en el archivo.

                En el caso de que estemos manejando todo el css dentro de un solo arhivo, podríamos indicar adelante de los selectores, el css principal por ejemplo el de App.

            74. CSS Modules & Media Queries
                Con CSS Modules, tenemos la info separada, js por un lado css por otro, y aparte de importar el css solo en el js que lo necesitamos. Recomendable este en la misma carpeta del componente junto al js.

            75. More on CSS Modules
                CSS Modules are a relatively new concept (you can dive super-deep into them here: https://github.com/css-modules/css-modules). With CSS modules, you can write normal CSS code and make sure, that it only applies to a given component.

                It's not using magic for that, instead it'll simply automatically generate unique CSS class names for you. And by importing a JS object and assigning classes from there, you use these dynamically generated, unique names. So the imported JS object simply exposes some properties which hold the generated CSS class names as values.

                Example:

                In Post.css File

                .Post {
                    color: red;
                }
                In Post Component File

                import classes from './Post.css';

                const post = () => (
                    <div className={classes.Post}>...</div>
                );
                Here, classes.Post  refers to an automatically generated Post  property on the imported classes  object. That property will in the end simply hold a value like Post__Post__ah5_1 .

                So your .Post  class was automatically transformed to a different class (Post__Post__ah5_1 ) which is unique across the application. You also can't use it accidentally in other components because you don't know the generated string! You can only access it through the classes  object. And if you import the CSS file (in the same way) in another component, the classes  object there will hold a Post  property which yields a different (!) CSS class name. Hence it's scoped to a given component.

                By the way, if you somehow also want to define a global (i.e. un-transformed) CSS class in such a .css  file, you can prefix the selector with :global .

                Example:

                :global .Post { ... }

                Now you can use className="Post"  anywhere in your app and receive that styling.

            76. Useful Resources & Links
                Using CSS Modules in create-react-app Projects: https://medium.com/nulogy/how-to-use-css-modules-with-create-react-app-9e44bec2b5c2
                More information about CSS Modules: https://github.com/css-modules/css-modules
                Recursos de esta clase
                styling--01-radium.zip
                styling--02-styled-components.zip
                styling--03-finished.zip

            Desde acá hasta el 75, cambio todo, esto es viejo:
                70. MUST READ: Enabling CSS Modules

                    // Para habilitar CSS Modules:
                    1) commitear los cambios que puedas tener
                    2) npm run eject
                    3) Vamos a ver nuevas carpetas:
                        /config -->
                        /scripts --> Tiene un script por cada comando en scripts a ejecutar

                    4) Modificar el archivo en config/webpack.config.js

                    test: cssRegex,
                            exclude: cssModuleRegex,
                            use: getStyleLoaders({
                                importLoaders: 1,
                                modules: true,
                                localIdentName: '[name]__[local]__[hash:base64:5]',
                                sourceMap: isEnvProduction && shouldUseSourceMap,
                            }),

                        debería modificarse también en el de prod, pero no lo tengo.. igual que otros archivos que el tiene y yo no.
                    5) Modificamos el import del css: import clases from './App.css'
                        las clases que tenemos en el archivo pasan a ser propiedades :O
                    6) Cambiamos
                        <div className="App">
                        por:
                        <div className={clases.App}>

                        Transforma la info que esta en la clase en unica.
                    7) Si revisamos el html vemos que tiene un nombre de clase super extraño :D

                71. Enabling & Using CSS Modules

                    // Para habilitar CSS Modules:
                    1) commitear los cambios que puedas tener
                    2) npm run eject
                    3) Vamos a ver nuevas carpetas:
                        /config -->
                        /scripts --> Tiene un script por cada comando en scripts a ejecutar

                    4) Modificar el archivo en config/webpack.config.js

                    test: cssRegex,
                            exclude: cssModuleRegex,
                            use: getStyleLoaders({
                                importLoaders: 1,
                                modules: true,
                                localIdentName: '[name]__[local]__[hash:base64:5]',
                                sourceMap: isEnvProduction && shouldUseSourceMap,
                            }),

                        debería modificarse también en el de prod, pero no lo tengo.. igual que otros archivos que el tiene y yo no.
                    5) Modificamos el import del css: import clases from './App.css'
                        las clases que tenemos en el archivo pasan a ser propiedades :O
                    6) Cambiamos
                        <div className="App">
                        por:
                        <div className={clases.App}>

                        Transforma la info que esta en la clase en unica.
                    7) Si revisamos el html vemos que tiene un nombre de clase super extraño :D

                72. More on CSS Modules

                    CSS Modules are a relatively new concept (you can dive super-deep into them here: https://github.com/css-modules/css-modules). With CSS modules, you can write normal CSS code and make sure, that it only applies to a given component.

                    It's not using magic for that, instead it'll simply automatically generate unique CSS class names for you. And by importing a JS object and assigning classes from there, you use these dynamically generated, unique names. So the imported JS object simply exposes some properties which hold the generated CSS class names as values.

                    Example:

                    In Post.css File

                    .Post {
                        color: red;
                    }
                    In Post Component File

                    import classes from './Post.css';

                    const post = () => (
                        <div className={classes.Post}>...</div>
                    );
                    Here, classes.Post  refers to an automatically generated Post  property on the imported classes  object. That property will in the end simply hold a value like Post__Post__ah5_1 .

                    So your .Post  class was automatically transformed to a different class (Post__Post__ah5_1 ) which is unique across the application. You also can't use it accidentally in other components because you don't know the generated string! You can only access it through the classes  object. And if you import the CSS file (in the same way) in another component, the classes  object there will hold a Post  property which yields a different (!) CSS class name. Hence it's scoped to a given component.

                    By the way, if you somehow also want to define a global (i.e. un-transformed) CSS class in such a .css  file, you can prefix the selector with :global .

                    Example:

                    :global .Post { ... }

                    Now you can use className="Post"  anywhere in your app and receive that styling.

                73. Adding Pseudo Selectors

                    Elimina todo el css que andaba por los archivos. Lo voy a eliminar cualquier cosa ver commit "elime css por curso 72"

                    .App button {
                        border: 1px solid blue;
                        padding: 16px;
                        background-color : green;
                        font: inherit;
                    }

                    Sigue funcionando todo porque:
                    <div className={classes.App}>
                        <button
                    </div


                    btnClass = classes.Red;
                    <button
                        className={btnClass}

                74. Working with Media Queries

                    Person.css
                    @media (min-width: 500px) {
                        .Person {
                            width: 450px;
                        }
                    }

                    no se que pasa que no funciona.

                75. Useful Resources & Links

                    Using CSS Modules in create-react-app Projects: https://medium.com/nulogy/how-to-use-css-modules-with-create-react-app-9e44bec2b5c2
                    More information about CSS Modules: https://github.com/css-modules/css-modules
                    Recursos de esta clase
                    styling--01-radium.zip
                    styling--02-css-modules-finished.zip

    ### Sección 7: Diving Deeper into Components & React Internals

        89. class Component Lifecycle Overview

            - Solo esta disponible en class Component.
            - Hay un monton de metodos, que react corre por nosotross, ej:
            contructor(), getDerivedStateFromProps()...

            IMPORTANTE: no realizar "side effects" en el construtor, como:
                http request, store aglo en la base. Usar solo para inicializar variables.

            Ejemplos de llamados de metodos en orden:

                1) constructor
                2) getDerivedStateFromProps
                    Cuando las props cambien para la clase. Idem constructor, no side effects acá.

                3) render
                    prepara y estructura tu jsx para retornarlo.

                4) Child components:
                    Se renderizan estos components.

                5) ComponentDidMount()
                    Acá se pueden generar "side effects"
                    NO ACTUALIZAR EL ESTADO ACA. Salvo que se cumpla una promesa sobre un llamado http.

        91. Component Update Lifecycle (for props Changes)

            lifecycle-update-external-learning-card (1)
            cmp-deep-dive-02-updating-lifecycle-props

            Ciclo de vida para actualizar los componentes.
                Cuando cambian las props o el estado

            1) getDerivedStateFromProps(props, state)
                No se usa amenudo, se utiliza para inicializar el estado de un componente que se actualiza en funcion de los accesorios que esta obteniendo. ej, algun control de form que obtiene propieades externas y luego internamente desea manejar la entrada del usuario pero inicializa su estado o actualiza el estado en función de cmbioas externos.
                Sirve para sincronizar tu estado local dentro del component, no debería realizar side effects, por lo que no se deberían realizar llamadas http.

            2) shouldComponentUpdate(nextProps, nextState)
                permite cancelar el proceso de actualización, o sea, si react debe continuar evaluando y renderizando el componente o no.
                se usa para optimizar el rendimiento.
                tener cuidado porque podes bloquear tus componentes

            3) render()
                revisa el codigo JSX, lo evalua y basicamente construye su dom virtual

            4) Update Child Components Props
                Evalua todos los hijos secundarios que tengas en tu JSX y los actualiza

            5) getSnapshotBeforeUpdate(prevProps, prevState)
                devuelve un objeto snapshot que se puede configurar.
                también es un enlace de ciclo de vida que no se usa demasiado.
                se usa para operaciones de ultimo momento en el dom, no cambios, sino como obtener la posición de desplazamiento actual del usuario.
                suponiendo que su proxima actualizacion del dom va a volver a representar el dom y agregara nuevos elementos y por lo tanto queres restaurar donde estaba el usuario posicionado.

            6) componentDidUpdate(prevProps, prevState, snapshot)
                un enlace de ciclo de vida que te "avisa" que terminó la actualización del componente.
                acá si se pueden realizar llamadas http
                LOOP INFINITOO ALERT:
                    no actualice el stado aqui porque sino va a causar re-renderizado nuevamente.

        104. Using React.Fragment

            En vez de usar Aux, se puede usar <React.Fragment> si no queremos usarlo así (separado por el punto, hay que importar Fragment)
            import React, { Fragment} from 'react'

            Hace lo mismo que Aux.

        105. Higher Order Components (HOC) - Introduction

            Se llama así porque contiene un componente, no hace nada.

            También puede haber componentes HOC:
                Puede ser por ej el div con className App.

            Otro ejemplo:
                Crea el archivo /hoc/WithClass.js

                import React from 'react';

                const withClass = props => {
                    <div className={props.classes}>
                        {props.children}
                    </div>
                };

                export default withClass;

            CONVENCIÓN: Los archivos de hoc, tienen que tener With adelante.

            Cambia el div de app por este withClass y le pasa classes por props.

        106. Another Form of HOCs

            Existe otra manera de crear las clases tipo withClass.

            Devolver una función comun de Javascript.
            1) parametro que debe arrancar con mayuscula
            2) algo que necesitemos en el componente hoc.
            3) Puede tener n parametros (obvio los que necesitas nada mas.)

            const withClass = (WrappedComponent, className) => {
                // Retorno un componente funcional.
                return props => (
                    <div className={className}>
                    <WrappedComponent></WrappedComponent>
                    </div>
                );
            };

            4) Usamos el componente Aux en App y cambiamos el nombre del js a tener w minuscula, porque ahora estamos devolviendo una función no un componente.
            5) modificamos el export de App:
                export default withClass(App, classes.App);

                Esto se usa dependiendo de que necesitemos.

        109. Using PropTypes

            No necesariamente son necesarias, pero cuando trabaja en un equipo grande o que queres distribuir lo que estás haciendo, evitas que la gente pase mal las propiedades.

            Hay que:

                1) Instalar prop-types
                    > npm install --save prop-types
                2) Importarlo:
                    import PropTypes from 'prop-types';
                3) Agregar antes del export:

                    NOTA: va con minuscula acá:

                    Person.propTypes = {
                        click: PropTypes.func,
                        name: PropTypes.string,
                        age: PropTypes.number
                    }

            IMPORTANTE:
                - Funciona en cualquier tipo de componente.
                - Te avisa si estas pasando una propiedad incorrecta EN DEVELOPMENT MODE.
                - Podes usarlo en el componente que creas necesario.
        
    ### Sección 9: Reaching out to the Web (Http / Ajax)

        161. Understanding our Project and Introducing Axios
            Habla de que se puede hacer algo con Javascript, pero ya existen paquetes que hacen todo mas facil, como axios.

            npm install axios --save

        162. Creating a Http Request to GET Data
            simula llamadas a una api, con json placeholder

            axios.get(url)
                .then(response => {
                    console.log(response);
                }) // cuando se resuelva la promesa, cae en then.

        163. Rendering Fetched Data to the Screen
            guarda la info que retorna la api en el state, y después con map genera los componentes necesarios dependiendo de cuanta info vino en el repsonse.

        164. Transforming Data
            usa slice para en vez de mostrar todos los elementos del response, mostrar solo los primeros 4.
            Envia por atributos/props la info y arregla el componente para que muestre bien todo.

        165. Making a Post Selectable
            Hace una función y se la pasa al componente que termina renderizando un mensaje o la info que seleccionaste.

        166. Fetching Data on Update (without Creating Infinite Loops)
            Valida que el fetch se haga si y solo si, el id que esta queriendo cargar es difernete al que esta cargado.
            Sino esto genera un loop infinito de requests.

        167. POSTing Data to the Server
            axios.post(url, data)
                .then(response => {
                    console.log(response);
                })

        168. Sending a DELETE Request
            axios.delete(url, this.props.id)
                .then(response => {
                    console.log(response);
                })

        170. Handling Errors Locally
            a la llamada de axios aparte de .then, se le puede agregar
            .catch(response => {
                this.setState({error: true});
            })

        171. Adding Interceptors to Execute Code Globally
            Para cuando queres hacer cosas como agregar headers que tienen que ir siempre, en app.js
            importa axios.
            Tiene 2 parametros, en uno recibimos la config del request y después podemos manejar los errores que puedean ocurrir.

            axios.interceptors.request.use(request =>  {
                console.log(request);
                // Editamos la configuración del request (que es lo que hay en request en si)
                return request; // siempre tenemos que retornar request, sino estamos bloqueando el request.
            }, error => { -> esto es para cuando hay errores de conectividad, no un 400 bad request por ej
                return Promise.reject(error);
            })


            También podemos manejar los response.
            axios.interceptors.response.use(response => {
                console.log(response);
                return response;
            }, error => {
                console.log(error);
                return Promise.reject(error);
            });


            Hay otr manera también de acceder a las configuraciones, la muestra en la proxima.

        172. Removing Interceptors
            You learned how to add an interceptor, getting rid of one is also easy. Simply store the reference to the interceptor in a variable and call eject  with that reference as an argument, to remove it (more info: https://github.com/axios/axios#interceptors):

            var myInterceptor = axios.interceptors.request.use(function () {/*...*/});
            axios.interceptors.request.eject(myInterceptor);

        173. Setting a Default Global Configuration for Axios
            En app.js

            axios.defaults.BaseUrl = 'la url de mi api'; -> sacamos en nuestras llamadas la parte del server:port
            axios.defaults.headers.common['Authorization'] = 'AUTH TOKEN'; -> que venga con el token
            axios.defaults.headers.post['Content-Type'] = 'application/json' -> que solo para los post pida esto, se puede con cualquier metodo

        174. Creating and Using Axios Instances
            se puede configurar diferentes url base, usando diferentes instancias.

            crea un nuevo archivo axios.js y:
                importa axios

                const instance = axios.create({
                    baseURL: 'mi url',

                })

                //axios.defaults.headers.common['Authorization'] = 'AUTH TOKEN';
                instance.headers.common['Authorization'] = 'AUTH TOKEN'; -> solo para esta instancia con esa url.

                export default instance;

            en donde la necesitamos ahora importamos este archivo en vez de axios.

    ### Sección 11: Multi-Page-Feeling in a Single-Page-App: Routing

        213. Working with Guards

    ### Sección 18: Adding Authentication to our Burger Project

        326. Getting a Token from the Backend
            
        336. Persistent Auth State with localStorage
            Agrega en el local storage el token que obtiene, y también en localStorage agrega un expirationDate.

            let expirationDate = new Date(new Date().getTime() + response.data.expiresIn * 1000);
            localStorage('expirationDate', expirationDate);

            
    ### Sección 22: Bonus: Working with Webpack

        370. Module Introduction
        371. Introducing Webpack

            Es un bundler, pero es mas que eso. Un bundler solo concatenaría archivos.

            También optimiza archivos, conectar complementos, loaders, transformarlos, transpilarlos, etc.

            La de gral es: tenes multiples archivos, js, css e imagenes, cualquier archivo y lo que hace webpack es analizar cada uno, bundlearlos pero a su vez, verificar cuales estan conectados (imports)...

        372. How Webpack works

            De tras de escena, webpack tiene 4 features importantes:

            1) Necesita al menos un entry point, por ej App.js
                Ya que ahí es donde se inserta todo en el dom y analiza este archivo verificando sus dependencias.

            2) Loaders:
                Esto esta en el medio, ej loaders (babel-loader, css-load). O sea, lo que vos le decis al loeader es como va a manejar todos los archivos de un determinado tipo, por ejemplo los de js van a ser manejados por tal package.

            3) Plugins:
                Concatenan los files, ej uglify, esta de manera global, minifica los archivos, optimizandolos.

            4) Analiza todas las dependencias y genera un unico archivo por ej dist/output.js, de manera ordenada y concatenadas.

        373. Basic Workflow Requirements

            Vamos a analizar los requesitos que tenemos:
                1) Compilar next-gen javascript features.
                2) Handle JSX, o sea, que podamos usar jsx.
                3) CSS Autoprefixing. O sea, manejar la mayor cantidad de sintaxis en los diferentes navegadores.
                4) Soportar imagenes. O sea, importarlas como si fuera un archivo.
                5) Optimizar el código (minificar los js)

        374. Project & npm Setup

            1) Crea un archivo .gitignore
                node_modules

            2) npm init
            3) npm install --save-dev webpack webpack-dev-server      -> Solo para desarrollo. Estos dos paquetes van de la mano.
            4)

        375. Creating a Basic Folder & File Structure

            Recrea algo semejante a la estructura de cra.

            src/
                assets/
                components/
                containers/
                index.css               --> para estilos globales.
                index.js
                index.html
                    <div id="root">
                App.js                  --> Mi componente root.

        376. Creating the Basic React Application
            components/
                PizzaImage/
                    PizzaImage.js
                    PizzaImage.css

            containers
                Pizza.js
                Users.js

            assets/
                pizza.jpg


            hoc/
                asyncComponent.js       -> Usar el componente que ya creo antes, para cargar componentes de manera lazy.

            index.js
                Agrega BrowserRouter y envuelve <App /> y renderiza app con ReactDOM.

        377. Installing Production Dependencies

            Core dependencies:
                npm install --save react react-dom react-router-dom

        378. Setting Up the Basic Webpack Config

            Agregar en package.json un script para start

            1) "start": "webpack-dev-server"   -> Usa este package y ejecutalo (así tal cual no pasa nada. hay que instalar una dependencia mas, te lo dice en la consola).

            2) npm install --save-dev webpack-clic

            3) Si intentas correr npm start, te tira un error porque webpack no sabe que hacer con index.js no entiende que tiene que hacer.

            Agrega un archivo webpack.config.js provee la configuración para webpack.

            const path = require('path');    -> este paquete ya viene con node js.
            //__dirname  es una variable global que existe en node.

            module.expots = {
                mode: 'development',         -> le dice a webpack que optimizaciones hacer según el amb.
                entry: './src/index.js',
                output: {
                    path: path.resolve(__dirname, 'dist'),
                    filename: 'bundle.js',
                    publicPath: ''
                },
                devtool: 'cheap-module-eval-source-map'     -> controla como se genera el source map en debug x ej, si lo transforma o no. en la paguina oficial esta esto.
            };

        379. Adding File Rules & Babel

            Vamos a agregar para que entienda next-gen javascript, para eso tenemos que instalar Babel.

            Lo que hace Babel es transpilar los features nuevos de javascript a los viejos para que sean compatbiles en todos los navegadores.

            npm install --save-dev @babel/core @babel/preset-env @babel/preset-react @babel/preset-stage-2 babel-loader @babel/plugin-proposal-class-properties

            const path = require('path');    -> este paquete ya viene con node js.

            module.expots = {
                mode: 'development',         -> le dice a webpack que optimizaciones hacer según el amb.
                entry: './src/index.js',
                output: {
                    path: path.resolve(__dirname, 'dist'),
                    filename: 'bundle.js',
                    publicPath: ''
                },
                devtool: 'cheap-module-eval-source-map',     -> controla como se genera el source map en debug x ej, si lo transforma o no. en la paguina oficial esta esto.
                module: {
                    rules: [     -> cada regla es un objeto, donde vas a tener una propiedad test con una expression regular, donde vas a indicar que archivos van a estar alcanzados por cierta herramienta/plugin, por ej los archivos javascript, van a ser alcanzados por el loader y la herramienta va a ser babel-loader.
                        {
                            test: /\.js$/,
                            loader: 'babel-loader',
                            exclude: /node_modules/  -> no queremos que alcance la carpeta.
                        }
                    ]
                }
            };

                Creamos un nuevo archivo .babelrc es un archivo de confugración para babel que se escribe en formato JSON.
                Todo esto esta en la pagina oficial de Babel.

                {
                    "presets": [ -> acá tenemos que aplicar todos los presets que queremos.
                        [
                            "@babel/preset-env",
                            {
                                "targets": {
                                    "browsers": ["> 1%", "last 2 versions"] -> compila para que compile en estos browser.
                                }
                            }
                        ],
                        "@babel/preset-react"   -> no necesita ser un array porque no es necesario presets.
                    ],
                    "plugins": [    -> config extra o comportamiento.
                        "@babel/plugin-proposal-class-properties"   -> controla que sintaxis soporta.
                    ]
                }

        380. Loading CSS Files

            npm install --save-dev style-loader css-loader (uno analiza los css y el otro toma los css y los inyecta en nuestro html. (style))

            agrega una regla al archivo webpack:

            {
                test: /\.css$/,
                exclude: /node_modules/,
                use: [
                    { loader: 'style-loader' },
                    {
                        loader: 'css-loader',
                        options: {  -> necesita config extra para aceptar css-modules.
                            importLoaders: 1,
                            modules: {
                                localIndentName: '[name]__[local]__[hash:base:5]'
                            }
                        }
                    },
                    {
                        loader: 'postcss-loader',  -> nos ayuda con el procesamiento de css y prefinxing para que pueda funcionar en navegadores viejos.
                        options: {
                            ident: 'postcsss',
                            plugins: () => [autoprefixer()]
                        }
                    }

                ]
            }

            npm install --save-dev postcss-loader
            npm install --save-dev autoprefixer
                Abajo del import de path en el archivo webpack:

                const autoprefixer = require('autoprefixer');
                    se agrega a la parte de plugins de postcssloader.

            en package.json agrega un script debajo de "licence"

            "browserslist": "> 1%, last 2 versions",

        381. Loading Images & Injecting into HTML Page

            Nos ayuda a cargar assets
                npm install --save-dev url-loader

            Dentro de webpackconfig
                {
                    test: /\.(png|jpe?g'|gif)$/,
                    loader: 'url-loader?limit=8000&name=images/[name].[ext]'
                }

            Para inyectar todas las transformaciones qe configuramos anteriormente en html:
                npm install --save-dev html-webpack-plugin
                    arriba de todo abajo de autoprefixer
                        const HtmlWebpackPlugin = require('html-webpack-plugin');

                dentro del config de webpack, antes del } final:

                plugins: [
                    new HtmlWebpackPlugin({
                        template: __dirname + '/src/index.html',
                        filename: 'index.html',
                        inject: 'body'
                    })
                ]

            npm install --save-dev file-loader  -> otro package necesario para webpack.

        382. Production Workflow & Wrap Up

            Copiamos y pegamos el webpack config y creamos un webpack.config.prod.js

            modificamos el development mode: 'production', en devtool: 'none'
            Agregamos un script debajo de start:

                "build:prod": "webpack --config webpack.config.prod.js"

            npm start -> vemos como se genera la carpeta dsit y esta todo bundleado.

        383. Adding babel-polyfill

            The current setup won't support all browsers theoretically supported by React. Features like Promises and Object.assign() are missing in older browsers - especially in IE of course.

            If you need to support these browsers, you need to add a polyfill (a package which provides these features for older browsers).

            The Babel docs explain how you can take advantage of Babel's built-in "Polyfill auto injecting" feature: https://babeljs.io/docs/en/babel-polyfill

            Simply install two packages:

            npm install --save core-js

            and

            npm install --save regenerator-runtime

            Change the config of your @babel/preset-env  babel preset in the .babelrc  file:

            "presets": [
                ["@babel/preset-env", {
                    "targets": {
                        "browsers": [
                            "> 1%",
                            "last 2 versions"
                        ]
                    },
                    "useBuiltIns": "usage"
                }],
                ...
            ],

        384. Useful Resources & Links
            Webpack Docs: https://webpack.js.org/concepts/
            More about Babel: https://babeljs.io/
            Recursos de esta clase
            webpack--01-basic-react-app.zip
            webpack--02-added-babel.zip
            webpack--03-finished.zip

   